#cython: language_level=3, linetrace=True

"""
The `quotonic.fock` module includes functions required to generate a list of states that together define 
the Fock basis for a provided number of photons $n$ and number of optical modes $m$.

All code in this module is adapted from [Bosonic: A Quantum Optics Library](https://github.com/steinbrecher/bosonic),
as originally designed for use in [G. R. Steinbrecher *et al*., “Quantum optical neural networks”, 
*npj Quantum Inf* **5**, 60 (2019)](https://doi.org/10.1038/s41534-019-0174-7).
"""

import itertools as it

import numpy as np

from quotonic.utilities import memoized

cimport numpy as np


@memoized
def getDim(numPhotons: int, numModes: int) -> int:
    """Calculate Fock basis dimension.

    Given a number of photons $n$ and a number of optical modes $m$, this function efficiently 
    computes the dimension of the corresponding Fock basis using `Cython` type definitions. 
    It is also `memoized` to ensure that it is not evaluated redundantly for a constant number 
    of photons and optical modes.

    The dimension of the Fock basis is given by $N = {n+m-1 \choose n}$. This operation can be
    expressed alternatively as,

    $$ N = {n+m-1 \choose n} = \\frac{(n+m-1)!}{n!(m-1)!} = \\frac{(n+m-1)(n+m-2)\\dots m}{n(n-1)\\dots 1}, $$

    which simplifies the algorithm.

    Args:
        numPhotons: Number of photons, $n$
        numModes: Number of optical modes, $m$

    Returns:
        Fock basis dimension, $N$
    """

    # Define all necessary integers
    cdef int i, n, nInit, top, numerator, denominator
    cdef int dim = 0

    # Store the top of {n + m - 1 \choose n}
    top = numPhotons + numModes - 1

    # Evaluate the simplified version of {n + m - 1 \choose n}
    i = 0
    numerator = 1
    denominator = 1
    while top - i >= numModes:
        numerator *= top - i
        i += 1
        denominator *= i
    dim += numerator // denominator
    
    return dim

@memoized
def basis(numPhotons: int, numModes: int) -> list:
    """Generate a list of Fock basis states.

    Given a number of photons $n$ and a number of optical modes $m$, this function creates each
    state in the Fock basis as a list of length $m$ where each element is an integer corresponding
    to the number of photons occupying a given optical mode. All of the states are then placed in a
    list that contains the entire basis. This function is also `memoized` to ensure that it is not 
    evaluated redundantly for a constant number of photons and optical modes.

    All possible combinations of the modes for the given number of photons are first computed and 
    stored in `modeBasis` as a list of tuples of the form `[(photon 1 mode, photon 2 mode, ..., 
    photon numPhotons mode), ...]`. For each element (`modeState`) of the `modeBasis`, a Fock basis 
    state is generated by counting the number of photons in each mode and creating a list of those 
    counts. Each of these lists corresponding to Fock basis states are appended to the full `fockBasis` 
    list of lists. Example results are displayed below for $n = 2$ photons and $m = 4$ optical modes:

    ```
    >>> modeBasis
    [(0, 0), (0, 1), (0, 2), (0, 3), (1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]

    >>> fockBasis
    [[2, 0, 0, 0], [1, 1, 0, 0], [1, 0, 1, 0], [1, 0, 0, 1], [0, 2, 0, 0], [0, 1, 1, 0], [0, 1, 0, 1], [0, 0, 2, 0], [0, 0, 1, 1], [0, 0, 0, 2]]
    ```

    $$ n = 2, m = 4 \implies \{\\left|2000\\right\\rangle, \\left|1100\\right\\rangle, \\left|1010\\right\\rangle, \\left|1001\\right\\rangle, \\left|0200\\right\\rangle, 
    \\left|0110\\right\\rangle, \\left|0101\\right\\rangle, \\left|0020\\right\\rangle, \\left|0011\\right\\rangle, \\left|0002\\right\\rangle\} $$

    Args:
        numPhotons: Number of photons, $n$
        numModes: Number of optical modes, $m$

    Returns:
        List of states in the Fock basis for $n$ photons and $m$ modes
    """

    # Initialize list of the Fock basis states
    fockBasis = []

    # Generate a list of tuples of all combinations of the modes for a given number of photons  
    modeBasis = list(it.combinations_with_replacement(range(numModes), numPhotons))
    
    # For each combination of modes, compute the number of photons in each mode 
    # and append a list that is representative of the Fock basis state
    for modeState in modeBasis:
      fockState = []
      for i in range(numModes):
        photonsInMode = modeState.count(i)
        fockState.append(photonsInMode)
      fockBasis.append(fockState)
      
    return fockBasis