
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="A platform for performing efficient simulations in the quantum photonic domain.">
      
      
        <meta name="author" content="Jacob Ewaniuk">
      
      
      
        <link rel="prev" href="fock.html">
      
      
        <link rel="next" href="aa.html">
      
      <link rel="icon" href="assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-9.0.13">
    
    
      
        <title>AWAWA - quotonic</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/main.ffa9267a.min.css">
      
        
        <link rel="stylesheet" href="assets/stylesheets/palette.a0c5b2b5.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL(".",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="deep-orange">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#quotonic.clements" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="index.html" title="quotonic" class="md-header__button md-logo" aria-label="quotonic" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            quotonic
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Clements
            
          </span>
        </div>
      </div>
    </div>
    
      <form class="md-header__option" data-md-component="palette">
        
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="deep-orange"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
          
            <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
            </label>
          
        
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="deep-orange"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
          
            <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
            </label>
          
        
      </form>
    
    
    
    
      <div class="md-header__source">
        <a href="https://github.com/QNLQueens/quotonic" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    QNLQueens/quotonic
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="index.html" title="quotonic" class="md-nav__button md-logo" aria-label="quotonic" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    quotonic
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/QNLQueens/quotonic" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    QNLQueens/quotonic
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="index.html" class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="fock.html" class="md-nav__link">
        Fock
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Clements
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="clements.html" class="md-nav__link md-nav__link--active">
        Clements
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#quotonic.clements" class="md-nav__link">
    quotonic.clements
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#quotonic.clements.Mesh" class="md-nav__link">
    Mesh
  </a>
  
    <nav class="md-nav" aria-label="Mesh">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#quotonic.clements.Mesh.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.clements.Mesh.decode" class="md-nav__link">
    decode()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.clements.Mesh.encode" class="md-nav__link">
    encode()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.clements.Mesh.mzi" class="md-nav__link">
    mzi()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.clements.Mesh.mzi_column" class="md-nav__link">
    mzi_column()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.clements.Mesh.set_SR" class="md-nav__link">
    set_SR()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.clements.Mesh.set_alpha" class="md-nav__link">
    set_alpha()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.clements.Mesh.set_phases" class="md-nav__link">
    set_phases()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="aa.html" class="md-nav__link">
        AA
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="kerr.html" class="md-nav__link">
        Kerr
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="qpnn.html" class="md-nav__link">
        QPNN
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="training_sets.html" class="md-nav__link">
        Training Sets
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="misc.html" class="md-nav__link">
        Miscellaneous
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#quotonic.clements" class="md-nav__link">
    quotonic.clements
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#quotonic.clements.Mesh" class="md-nav__link">
    Mesh
  </a>
  
    <nav class="md-nav" aria-label="Mesh">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#quotonic.clements.Mesh.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.clements.Mesh.decode" class="md-nav__link">
    decode()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.clements.Mesh.encode" class="md-nav__link">
    encode()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.clements.Mesh.mzi" class="md-nav__link">
    mzi()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.clements.Mesh.mzi_column" class="md-nav__link">
    mzi_column()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.clements.Mesh.set_SR" class="md-nav__link">
    set_SR()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.clements.Mesh.set_alpha" class="md-nav__link">
    set_alpha()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.clements.Mesh.set_phases" class="md-nav__link">
    set_phases()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


  <h1>Clements</h1>

<div class="doc doc-object doc-module">


<a id="quotonic.clements"></a>
  <div class="doc doc-contents first">
  
      <p>The <code>quotonic.clements</code> module includes a class that allows Mach-Zehnder interferometer (MZI) meshes AWAWA
arranged in the Clements configuration to be instantiated. For each instance, the user may specify
whether the mesh should exhibit ideal operation, or be subject to experimental imperfections including
photon propagation losses and/or imbalanced directional coupler splitting ratios. Once instantiated, the
user may supply a linear unitary transformation that is then decomposed into MZI phase shifts, or
alternatively provide MZI phase shifts to encode a linear unitary (non-unitary if imperfect) transformation.
Note that the code has been designed to produce accurate representations of <span class="arithmatex">\(2\times 2\)</span> meshes (i.e. a
single MZI followed by 2 output phase shifts), however, the documentation corresponds to cases where <span class="arithmatex">\(m &gt; 2\)</span>.</p>
<p>The code in this module has been inspired by the encoding proposed in <a href="https://doi.org/10.1364/OPTICA.3.001460">W. R. Clements <em>et al</em>., "Optimal
design for universal multiport interferometers", <em>Optica</em> <strong>3</strong>, 1460-1465 (2016)</a>,
and its <code>python</code> implementation in <a href="https://github.com/steinbrecher/bosonic">Bosonic: A Quantum Optics Library</a>,
as originally designed for use in <a href="https://doi.org/10.1038/s41534-019-0174-7">G. R. Steinbrecher <em>et al</em>., “Quantum optical neural networks”,
<em>npj Quantum Inf</em> <strong>5</strong>, 60 (2019)</a>.</p>

  

  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="quotonic.clements.Mesh" class="doc doc-heading">
        <code>Mesh</code>


<a href="#quotonic.clements.Mesh" class="headerlink" title="Permanent link">&para;</a></h2>


  <div class="doc doc-contents ">

  
      <p>Model of a linear Mach-Zehnder interferometer mesh arranged in the Clements configuration.</p>
<p>Each mesh of Mach-Zehnder interferometers (MZIs) is classified by a number of optical modes <span class="arithmatex">\(m\)</span>.
Also, fabrication imperfections can optionally be modelled by providing the mean and standard deviation
of the propagation losses, <span class="arithmatex">\(\alpha_\mathrm{WG}\)</span>, in <span class="arithmatex">\(\text{dB}/\text{cm}\)</span>, the standard deviation on the
splitting ratio of the nominally 50:50 directional couplers, and the lengths of components (MZI, phase
shifters, flat sections in parallel with MZIs) in <span class="arithmatex">\(\text{cm}\)</span>. The default lengths correspond to the
components considered in <a href="https://doi.org/10.1002/qute.202200125">J. Ewaniuk <em>et al</em>., "Imperfect Quantum Photonic Neural Networks",
<em>Adv Quantum Technol.</em> 2200125 (2023)</a>.</p>
<p>This class features methods to manipulate a mesh once it is constructed, including the generation of its
matrix representation (only unitary when <span class="arithmatex">\(\alpha_\mathrm{WG} = 0\text{ dB}/\text{cm}\)</span>) from MZI and
output phase shifts, and the decomposition of a matrix representation to identify the MZI and output phase
shifts required to realize it. This decomposition follows the scheme of Clements <em>et al</em>. (cited above),
yet has been adjusted to work with the MZI transfer matrix associated with integrated photonic circuits
(see <code>decode</code> for more details).</p>

  <p><strong>Attributes:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>numModes</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Number of optical modes, <span class="arithmatex">\(m\)</span></p></td>
        </tr>
        <tr>
          <td><code>alphaWG</code></td>
          <td>
                <code><span title="typing.Optional">Optional</span>[float]</code>
          </td>
          <td><p>Mean propagation losses, <span class="arithmatex">\(\alpha_\mathrm{WG}\)</span>, in <span class="arithmatex">\(\text{dB}/\text{cm}\)</span></p></td>
        </tr>
        <tr>
          <td><code>std_alphaWG</code></td>
          <td>
                <code><span title="typing.Optional">Optional</span>[float]</code>
          </td>
          <td><p>Standard deviation of the propagation losses, <span class="arithmatex">\(\alpha_\mathrm{WG}\)</span>, in <span class="arithmatex">\(\text{dB}/\text{cm}\)</span></p></td>
        </tr>
        <tr>
          <td><code>std_SR</code></td>
          <td>
                <code><span title="typing.Optional">Optional</span>[float]</code>
          </td>
          <td><p>Standard deviation of the directional coupler splitting ratio, <span class="arithmatex">\(t\)</span></p></td>
        </tr>
        <tr>
          <td><code>ellMZI</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Characteristic length of a MZI, <span class="arithmatex">\(\ell_\mathrm{MZI}\)</span>, in <span class="arithmatex">\(\text{cm}\)</span></p></td>
        </tr>
        <tr>
          <td><code>ellPS</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Characteristic length of a phase shifter, <span class="arithmatex">\(\ell_\mathrm{PS}\)</span>, in <span class="arithmatex">\(\text{cm}\)</span></p></td>
        </tr>
        <tr>
          <td><code>ellF</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Characteristic length of a flat section in parallel with a MZI, <span class="arithmatex">\(\ell_\mathrm{F}\)</span>, in <span class="arithmatex">\(\text{cm}\)</span></p></td>
        </tr>
        <tr>
          <td><code>phases</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A 1D array of length <span class="arithmatex">\(m^2\)</span> including MZI and output phase shifts for the Clements mesh</p></td>
        </tr>
        <tr>
          <td><code>alpha</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A 1D array of length <span class="arithmatex">\(m(m+1)\)</span> including the fractions of light lost, <span class="arithmatex">\(\alpha\)</span>, for each component in the Clements mesh</p></td>
        </tr>
        <tr>
          <td><code>SR</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A 1D array of length <span class="arithmatex">\(m(m-1)\)</span> including the splitting ratios, <span class="arithmatex">\(t\)</span>, for each directional coupler in the Clements mesh</p></td>
        </tr>
    </tbody>
  </table>


        <details class="quote">
          <summary>Source code in <code>quotonic/clements.py</code></summary>
          <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Mesh</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Model of a linear Mach-Zehnder interferometer mesh arranged in the Clements configuration.</span>

<span class="sd">    Each mesh of Mach-Zehnder interferometers (MZIs) is classified by a number of optical modes $m$.</span>
<span class="sd">    Also, fabrication imperfections can optionally be modelled by providing the mean and standard deviation</span>
<span class="sd">    of the propagation losses, $\\alpha_\\mathrm{WG}$, in $\\text{dB}/\\text{cm}$, the standard deviation on the</span>
<span class="sd">    splitting ratio of the nominally 50:50 directional couplers, and the lengths of components (MZI, phase</span>
<span class="sd">    shifters, flat sections in parallel with MZIs) in $\\text{cm}$. The default lengths correspond to the</span>
<span class="sd">    components considered in [J. Ewaniuk *et al*., &quot;Imperfect Quantum Photonic Neural Networks&quot;,</span>
<span class="sd">    *Adv Quantum Technol.* 2200125 (2023)](https://doi.org/10.1002/qute.202200125).</span>

<span class="sd">    This class features methods to manipulate a mesh once it is constructed, including the generation of its</span>
<span class="sd">    matrix representation (only unitary when $\\alpha_\\mathrm{WG} = 0\\text{ dB}/\\text{cm}$) from MZI and</span>
<span class="sd">    output phase shifts, and the decomposition of a matrix representation to identify the MZI and output phase</span>
<span class="sd">    shifts required to realize it. This decomposition follows the scheme of Clements *et al*. (cited above),</span>
<span class="sd">    yet has been adjusted to work with the MZI transfer matrix associated with integrated photonic circuits</span>
<span class="sd">    (see `decode` for more details).</span>

<span class="sd">    Attributes:</span>
<span class="sd">        numModes (int): Number of optical modes, $m$</span>
<span class="sd">        alphaWG (Optional[float]): Mean propagation losses, $\\alpha_\\mathrm{WG}$, in $\\text{dB}/\\text{cm}$</span>
<span class="sd">        std_alphaWG (Optional[float]): Standard deviation of the propagation losses, $\\alpha_\\mathrm{WG}$, in $\\text{dB}/\\text{cm}$</span>
<span class="sd">        std_SR (Optional[float]): Standard deviation of the directional coupler splitting ratio, $t$</span>
<span class="sd">        ellMZI (float): Characteristic length of a MZI, $\\ell_\\mathrm{MZI}$, in $\\text{cm}$</span>
<span class="sd">        ellPS (float): Characteristic length of a phase shifter, $\\ell_\\mathrm{PS}$, in $\\text{cm}$</span>
<span class="sd">        ellF (float): Characteristic length of a flat section in parallel with a MZI, $\\ell_\\mathrm{F}$, in $\\text{cm}$</span>
<span class="sd">        phases (np.ndarray): A 1D array of length $m^2$ including MZI and output phase shifts for the Clements mesh</span>
<span class="sd">        alpha (np.ndarray): A 1D array of length $m(m+1)$ including the fractions of light lost, $\\alpha$, for each component in the Clements mesh</span>
<span class="sd">        SR (np.ndarray): A 1D array of length $m(m-1)$ including the splitting ratios, $t$, for each directional coupler in the Clements mesh</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">numModes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">alphaWG</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">std_alphaWG</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">std_SR</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ellMZI</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.028668</span><span class="p">,</span>
        <span class="n">ellPS</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0050</span><span class="p">,</span>
        <span class="n">ellF</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.028668</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialization of a MZI mesh arranged in the Clements configuration.</span>

<span class="sd">        The properties of the mesh are first saved, and its phase shifts are initialized as zeroes. If losses</span>
<span class="sd">        are provided, then component-by-component loss probabilities are computed and stored either by</span>
<span class="sd">        selecting them randomly from a normal distribution (if a standard deviation is provided), or by</span>
<span class="sd">        computing the uniform losses for each component. In either case, the mean fraction of light lost,</span>
<span class="sd">        $\\alpha$, is given by,</span>

<span class="sd">        $$ \\alpha = 1 - 10^{-\\frac{\\alpha_\\mathrm{WG}\\ell}{10}}, $$</span>

<span class="sd">        for a given component of charactersitic length $\\ell$ and photon propagation losses</span>
<span class="sd">        in $\\text{dB}/\\text{cm}$ of $\\alpha_\\mathrm{WG}$, The loss probabilities are concatenated</span>
<span class="sd">        into a single 1D array ordered as follows: loss in each optical mode for MZI column 1, loss in each</span>
<span class="sd">        optical mode for MZI column 2, ..., loss in each optical mode for output phase shift column. If a</span>
<span class="sd">        standard deviation on the directional coupler splitting ratios is provided, then specific splitting</span>
<span class="sd">        ratios are selected randomly from a normal distribution for each directional coupler in the mesh.</span>
<span class="sd">        Similarly, these are concatenated into a single 1D array ordered as follows: ratios for the two</span>
<span class="sd">        directional couplers in the top MZI of column 1, ..., ratios for the two directional couplers in</span>
<span class="sd">        the bottom MZI of column 1, ratios for the two directional couplers in the top MZI of column 2,</span>
<span class="sd">        ..., ratios for the two directional couplers in the bottom MZI of column 2, etc.</span>

<span class="sd">        Args:</span>
<span class="sd">            numModes: Number of optical modes, $m$</span>
<span class="sd">            alphaWG: Mean propagation losses, $\\alpha_\\mathrm{WG}$, in $\\text{dB}/\\text{cm}$</span>
<span class="sd">            std_alphaWG: Standard deviation of the propagation losses, $\\alpha_\\mathrm{WG}$, in $\\text{dB}/\\text{cm}$</span>
<span class="sd">            std_SR: Standard deviation of the directional coupler splitting ratio, $t$</span>
<span class="sd">            ellMZI: Characteristic length of a MZI, $\\ell_\\mathrm{MZI}$, in $\\text{cm}$</span>
<span class="sd">            ellPS: Characteristic length of a phase shifter, $\\ell_\\mathrm{PS}$, in $\\text{cm}$</span>
<span class="sd">            ellF: Characteristic length of a flat section in parallel with a MZI, $\\ell_\\mathrm{F}$, in $\\text{cm}$</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Store the provided properties of the mesh and initialize the phases</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">=</span> <span class="n">numModes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alphaWG</span> <span class="o">=</span> <span class="n">alphaWG</span>  <span class="c1"># dB/cm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std_alphaWG</span> <span class="o">=</span> <span class="n">std_alphaWG</span>  <span class="c1"># dB/cm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std_SR</span> <span class="o">=</span> <span class="n">std_SR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ellMZI</span> <span class="o">=</span> <span class="n">ellMZI</span>  <span class="c1"># cm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ellPS</span> <span class="o">=</span> <span class="n">ellPS</span>  <span class="c1"># cm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ellF</span> <span class="o">=</span> <span class="n">ellF</span>  <span class="c1"># cm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numModes</span> <span class="o">*</span> <span class="n">numModes</span><span class="p">)</span>

        <span class="c1"># If losses are provided, compute the loss probability contributed by each component in the mesh</span>
        <span class="k">if</span> <span class="n">alphaWG</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If losses are non-uniform, loss probabilities are selected randomly from a normal distribution</span>
            <span class="k">if</span> <span class="n">std_alphaWG</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># MZI losses</span>
                <span class="n">mu_alphaMZI</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">ellMZI</span> <span class="o">*</span> <span class="n">alphaWG</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
                <span class="n">sigma_alphaMZI</span> <span class="o">=</span> <span class="n">std_alphaWG</span> <span class="o">*</span> <span class="n">ellMZI</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">alphaWG</span> <span class="o">*</span> <span class="n">ellMZI</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span>
                <span class="n">alphaMZI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">mu_alphaMZI</span><span class="p">,</span> <span class="n">sigma_alphaMZI</span><span class="p">,</span> <span class="n">numModes</span> <span class="o">*</span> <span class="p">(</span><span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

                <span class="c1"># Phase shifter losses</span>
                <span class="n">mu_alphaPS</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">ellPS</span> <span class="o">*</span> <span class="n">alphaWG</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
                <span class="n">sigma_alphaPS</span> <span class="o">=</span> <span class="n">std_alphaWG</span> <span class="o">*</span> <span class="n">ellPS</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">alphaWG</span> <span class="o">*</span> <span class="n">ellPS</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span>
                <span class="n">alphaPS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">mu_alphaPS</span><span class="p">,</span> <span class="n">sigma_alphaPS</span><span class="p">,</span> <span class="n">numModes</span><span class="p">)</span>

                <span class="c1"># Flat section losses</span>
                <span class="n">mu_alphaF</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">ellF</span> <span class="o">*</span> <span class="n">alphaWG</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
                <span class="n">sigma_alphaF</span> <span class="o">=</span> <span class="n">std_alphaWG</span> <span class="o">*</span> <span class="n">ellF</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">alphaWG</span> <span class="o">*</span> <span class="n">ellF</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span>
                <span class="n">alphaF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">mu_alphaF</span><span class="p">,</span> <span class="n">sigma_alphaF</span><span class="p">,</span> <span class="n">numModes</span><span class="p">)</span>

            <span class="c1"># If losses are uniform, loss probabilities are computed just once for each component</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">alphaMZI</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">ellMZI</span> <span class="o">*</span> <span class="n">alphaWG</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">numModes</span> <span class="o">*</span> <span class="p">(</span><span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">alphaPS</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">ellPS</span> <span class="o">*</span> <span class="n">alphaWG</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">numModes</span><span class="p">)</span>
                <span class="n">alphaF</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">ellF</span> <span class="o">*</span> <span class="n">alphaWG</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">numModes</span><span class="p">)</span>

            <span class="c1"># Arrange the loss probabilities to match the arrangement of the encoding scheme</span>
            <span class="k">if</span> <span class="n">numModes</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alphaMZI</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">alphaPS</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">alphaF</span><span class="p">))</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">indMZI</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">indF</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">numModes</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numModes</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">ind</span> <span class="p">:</span> <span class="n">ind</span> <span class="o">+</span> <span class="n">numModes</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaMZI</span><span class="p">[</span><span class="n">indMZI</span> <span class="p">:</span> <span class="n">indMZI</span> <span class="o">+</span> <span class="n">numModes</span><span class="p">]</span>
                            <span class="n">indMZI</span> <span class="o">+=</span> <span class="n">numModes</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">ind</span> <span class="p">:</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaF</span><span class="p">[</span><span class="n">indF</span> <span class="p">:</span> <span class="n">indF</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">ind</span> <span class="o">+</span> <span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaMZI</span><span class="p">[</span><span class="n">indMZI</span> <span class="p">:</span> <span class="n">indMZI</span> <span class="o">+</span> <span class="n">numModes</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">ind</span> <span class="o">+</span> <span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">ind</span> <span class="o">+</span> <span class="n">numModes</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaF</span><span class="p">[</span><span class="n">indF</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">indF</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
                            <span class="n">indMZI</span> <span class="o">+=</span> <span class="n">numModes</span> <span class="o">-</span> <span class="mi">2</span>
                            <span class="n">indF</span> <span class="o">+=</span> <span class="mi">2</span>
                        <span class="n">ind</span> <span class="o">+=</span> <span class="n">numModes</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numModes</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">ind</span> <span class="p">:</span> <span class="n">ind</span> <span class="o">+</span> <span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaMZI</span><span class="p">[</span><span class="n">indMZI</span> <span class="p">:</span> <span class="n">indMZI</span> <span class="o">+</span> <span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">ind</span> <span class="o">+</span> <span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">ind</span> <span class="o">+</span> <span class="n">numModes</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaF</span><span class="p">[</span><span class="n">indF</span> <span class="p">:</span> <span class="n">indF</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">ind</span> <span class="p">:</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaF</span><span class="p">[</span><span class="n">indF</span> <span class="p">:</span> <span class="n">indF</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">ind</span> <span class="o">+</span> <span class="n">numModes</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaMZI</span><span class="p">[</span><span class="n">indMZI</span> <span class="p">:</span> <span class="n">indMZI</span> <span class="o">+</span> <span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">indMZI</span> <span class="o">+=</span> <span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">indF</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">ind</span> <span class="o">+=</span> <span class="n">numModes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alphaMZI</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">alphaPS</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaMZI</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">ind</span><span class="p">::]</span> <span class="o">=</span> <span class="n">alphaPS</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numModes</span> <span class="o">*</span> <span class="p">(</span><span class="n">numModes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># If directional coupler splitting ratios vary, select them randomly from a normal distribution</span>
        <span class="k">if</span> <span class="n">std_SR</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">std_SR</span><span class="p">,</span> <span class="n">numModes</span> <span class="o">*</span> <span class="p">(</span><span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># If directional coupler splitting ratios do not vary, then they are all 50:50</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SR</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">numModes</span> <span class="o">*</span> <span class="p">(</span><span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">set_phases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phases</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set all phase shifts in the Clements mesh.</span>

<span class="sd">        A Clements mesh with $m$ optical modes features $m^2$ phase shifts. The phase shifts</span>
<span class="sd">        input here must be ordered in accordance with the encoding scheme. See `encode` for</span>
<span class="sd">        more details.</span>

<span class="sd">        Args:</span>
<span class="sd">            phases: A 1D array of length $m^2$ including MZI and output phase shifts for the Clements mesh</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">phases</span> <span class="o">=</span> <span class="n">phases</span>

    <span class="k">def</span> <span class="nf">set_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set all component losses in the Clements mesh.</span>

<span class="sd">        A Clements mesh with $m$ optical modes features $\\frac{1}{2}m(m-1)$ MZIs, $m$ flat</span>
<span class="sd">        sections in parallel with MZIs, and $m$ output phase shifters, each contributing a</span>
<span class="sd">        specific fraction of light lost when photons propagate through them. The MZIs may</span>
<span class="sd">        have imbalanced losses in each arm, and thus there are two values for the fraction</span>
<span class="sd">        of light lost per MZI. Here, all of the fractions can be specified manually, in the</span>
<span class="sd">        order in which each component appears during the encoding scheme. See `__init__` and</span>
<span class="sd">        `encode` for more details.</span>

<span class="sd">        Args:</span>
<span class="sd">            alpha: A 1D array of length $m(m+1)$ including the fractions of light lost, $\\alpha$, for each component in the Clements mesh</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>

    <span class="k">def</span> <span class="nf">set_SR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SR</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set all splitting ratios in the directional couplers of the Clements mesh.</span>

<span class="sd">        Each MZI in a Clements mesh features two directional couplers, each nominally with</span>
<span class="sd">        a 50:50 splitting ratio, however, this may vary in imperfect cases. Here, the</span>
<span class="sd">        splitting ratios, $t$, for the $m(m-1)$ directional couplers can be manually</span>
<span class="sd">        specified in the order at which they appear during the encoding scheme. See `__init__`</span>
<span class="sd">        and `encode` for more details.</span>

<span class="sd">        Args:</span>
<span class="sd">            SR: A 1D array of length $m(m-1)$ including the splitting ratios, $t$, for each directional coupler in the Clements mesh</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">SR</span> <span class="o">=</span> <span class="n">SR</span>

    <span class="k">def</span> <span class="nf">mzi</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">phi</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">twotheta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">SR1</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">SR2</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">alpha_up</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">alpha_low</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">inv</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct $2\\times 2$ MZI transfer matrix.</span>

<span class="sd">        Each MZI, as displayed below, consists of two phase shifters enacting respective</span>
<span class="sd">        phase shifts $\\phi$, $\\theta$, and two directional couplers with respective</span>
<span class="sd">        splitting ratios $t_1$, $t_2$ (ideally, $t_1 = t_2 = 0.5$).</span>

<span class="sd">        &lt;p align=&quot;center&quot;&gt;</span>
<span class="sd">        &lt;img width=&quot;500&quot; src=&quot;img/mzi.png&quot;&gt;</span>
<span class="sd">        &lt;/p&gt;</span>

<span class="sd">        The phase shifter transfer matrices are given by,</span>

<span class="sd">        $$ \\mathbf{T}_\\text{PS}(\\phi) = \\begin{pmatrix} e^{i\\phi} &amp; 0 \\\ 0 &amp; 1 \\end{pmatrix} \qquad\qquad</span>
<span class="sd">        \\mathbf{T}_\\text{PS}(2\\theta) = \\begin{pmatrix} e^{i2\\theta} &amp; 0 \\\ 0 &amp; 1 \\end{pmatrix}, $$</span>

<span class="sd">        for phase shifts $\\phi$ and $2\\theta$ respectively. The directional coupler</span>
<span class="sd">        transfer matrix is given by,</span>

<span class="sd">        $$ \\mathbf{T}_\\text{DC}(t) = \\begin{pmatrix} \\sqrt{t} &amp; i\\sqrt{1-t} \\\ i\\sqrt{1-t} &amp; \\sqrt{t} \\end{pmatrix}, $$</span>

<span class="sd">        which simplifies to,</span>

<span class="sd">        $$ \\mathbf{T}_\\text{DC}(0.5) = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 &amp; i \\\ i &amp; 1 \\end{pmatrix}, $$</span>

<span class="sd">        in the ideal case of $t = 0.5$ (i.e. 50:50). Each MZI may contribute an imbalanced</span>
<span class="sd">        probability of photon loss in each of its arms. This is modelled by multiplying a</span>
<span class="sd">        loss matrix,</span>

<span class="sd">        $$ \\mathbf{T}_\\text{loss}(\\alpha_\\text{up}, \\alpha_\\text{low}) = \\begin{pmatrix}</span>
<span class="sd">        \\sqrt{1 - \\alpha_\\text{up}} &amp; 0 \\\ 0 &amp; \\sqrt{1 - \\alpha_\\text{low}} \\end{pmatrix}, $$</span>

<span class="sd">        where $\\alpha_\\text{up}$, $\\alpha_\\text{low}$ are the fractions of light lost</span>
<span class="sd">        in the upper and lower arms of the MZI, respectively. Altogether, the MZI transfer</span>
<span class="sd">        matrix is given by,</span>

<span class="sd">        $$ \\mathbf{T}_\\text{MZI} = \\mathbf{T}_\\text{loss}(\\alpha_\\text{up}, \\alpha_\\text{low})\\mathbf{T}_\\text{DC}(t_2)\\mathbf{T}_\\text{PS}(2\\theta)</span>
<span class="sd">        \\mathbf{T}_\\text{DC}(t_1)\\mathbf{T}_\\text{PS}(\\phi) = \\begin{pmatrix} \\sqrt{1 - \\alpha_\\text{up}} &amp; 0 \\\ 0 &amp; \\sqrt{1 - \\alpha_\\text{low}} \\end{pmatrix}</span>
<span class="sd">        \\begin{pmatrix} \\sqrt{t_2} &amp; i\\sqrt{1-t_2} \\\ i\\sqrt{1-t_2} &amp; \\sqrt{t_2} \\end{pmatrix}\\begin{pmatrix} e^{i2\\theta} &amp; 0 \\\ 0 &amp; 1 \\end{pmatrix}</span>
<span class="sd">        \\begin{pmatrix} \\sqrt{t_1} &amp; i\\sqrt{1-t_1} \\\ i\\sqrt{1-t_1} &amp; \\sqrt{t_1} \\end{pmatrix}\\begin{pmatrix} e^{i\\phi} &amp; 0 \\\ 0 &amp; 1 \\end{pmatrix}, $$</span>

<span class="sd">        which simplifies to,</span>

<span class="sd">        $$ \\mathbf{T}_\\text{MZI} = \\mathbf{T}_\\text{loss}(0, 0)\\mathbf{T}_\\text{DC}(0.5)\\mathbf{T}_\\text{PS}(2\\theta)\\mathbf{T}_\\text{DC}(0.5)\\mathbf{T}_\\text{PS}(\\phi) =</span>
<span class="sd">        ie^{i\\theta}\\begin{pmatrix} e^{i\\phi}\\sin{\\theta} &amp; \\cos{\\theta} \\\ e^{i\\phi}\\cos{\\theta} &amp; -\\sin{\\theta} \\end{pmatrix}, $$</span>

<span class="sd">        in the ideal case of $t_1 = t_2 = 0.5$, $\\alpha_1 = \\alpha_2 = 0$. This</span>
<span class="sd">        function constructs the MZI transfer matrix from its parameters, and</span>
<span class="sd">        optionally returns its inverse, $\\mathbf{T}_\\text{MZI}^{-1}$, if</span>
<span class="sd">        `inv = True` is set.</span>

<span class="sd">        Args:</span>
<span class="sd">            phi: Phase shift $\\phi$</span>
<span class="sd">            twotheta: Phase shift $2\\theta$</span>
<span class="sd">            SR1: Splitting ratio of the first directional coupler in the MZI, $t_1$</span>
<span class="sd">            SR2: Splitting ratio of the second directional coupler in the MZI, $t_2$</span>
<span class="sd">            alpha_up: Fraction of light lost in the upper arm of the MZI, $\\alpha_\\text{up}$</span>
<span class="sd">            alpha_low: Fraction of light lost in the lower arm of the MZI, $\\alpha_\\text{low}$</span>
<span class="sd">            inv: Boolean that controls whether the MZI matrix or its inverse is returned</span>

<span class="sd">        Returns:</span>
<span class="sd">            A $2\\times 2$ 2D array that represents the MZI transfer matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Construct phase shifter transfer matrices</span>
        <span class="n">ps_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span><span class="p">),</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">))</span>
        <span class="n">ps_twotheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">twotheta</span><span class="p">),</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">))</span>

        <span class="c1"># Construct directional coupler transfer matrices</span>
        <span class="n">dc_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">SR1</span><span class="p">),</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">SR1</span><span class="p">)],</span> <span class="p">[</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">SR1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">SR1</span><span class="p">)]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">dc_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">SR2</span><span class="p">),</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">SR2</span><span class="p">)],</span> <span class="p">[</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">SR2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">SR2</span><span class="p">)]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

        <span class="c1"># Construct loss transfer matrix</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">alpha_up</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">alpha_low</span><span class="p">)]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

        <span class="c1"># Calculate full MZI transfer matrix</span>
        <span class="n">mzi</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">loss</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dc_2</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ps_twotheta</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dc_1</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ps_phi</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inv</span><span class="p">:</span>
            <span class="n">mzi_inv</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">mzi</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">return</span> <span class="n">mzi_inv</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mzi</span>

    <span class="k">def</span> <span class="nf">mzi_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">placementSpecifier</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">phis</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">twothetas</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">SRs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">alphas</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct MZI transfer matrix for a column of the Clements mesh.</span>

<span class="sd">        The Clements mesh (see `encode` for an example diagram) can be separated into</span>
<span class="sd">        columns of MZIs. Each MZI in a given column contributes a transformation,</span>
<span class="sd">        $\\mathbf{T}_{p,q}$, that is both block diagonal and $m\\times m$. Starting</span>
<span class="sd">        from the $m\\times m$ identity matrix, a $2\\times 2$ MZI transfer matrix is</span>
<span class="sd">        inserted into the block from element $(p,p)$ to element $(q,q)$. All the</span>
<span class="sd">        separate transformations in a given column commute which each other since they</span>
<span class="sd">        act on separate blocks. Thus, this function constructs all of the</span>
<span class="sd">        $\\mathbf{T}_{p,q}$ transformations in a given column as a single $m\\times m$</span>
<span class="sd">        matrix that is returned.</span>

<span class="sd">        The location of the first MZI transfer matrix insertion is controlled by</span>
<span class="sd">        `placementSpecifier`, then a $2\\times 2$ $\\mathbf{T}_\\text{MZI}$ can be</span>
<span class="sd">        inserted at each separated block along the diagonal. For example, consider</span>
<span class="sd">        $m = 5$, `placementSpecifier = 0`, and the ideal case with no imperfections.</span>
<span class="sd">        The output matrix will then incorporate the MZIs acting on the pair of modes</span>
<span class="sd">        $(0,1)$ and $(2,3)$. As the function proceeds, the matrix changes as,</span>

<span class="sd">        $$ \\begin{pmatrix} 1&amp;0&amp;0&amp;0&amp;0 \\\ 0&amp;1&amp;0&amp;0&amp;0 \\\ 0&amp;0&amp;1&amp;0&amp;0 \\\ 0&amp;0&amp;0&amp;1&amp;0 \\\ 0&amp;0&amp;0&amp;0&amp;1 \\end{pmatrix} \\longrightarrow</span>
<span class="sd">        \\begin{pmatrix} ie^{i\\theta_{0,1}}e^{i\\phi_{0,1}}\\sin{\\theta_{0,1}} &amp; ie^{i\\theta_{0,1}}\\cos{\\theta_{0,1}}&amp;0&amp;0&amp;0 \\\ ie^{i\\theta_{0,1}}e^{i\\phi_{0,1}}\\cos{\\theta_{0,1}} &amp; ie^{i\\theta_{0,1}}\\sin{\\theta_{0,1}}&amp;0&amp;0&amp;0</span>
<span class="sd">        \\\ 0&amp;0&amp;1&amp;0&amp;0 \\\ 0&amp;0&amp;0&amp;1&amp;0 \\\ 0&amp;0&amp;0&amp;0&amp;1 \\end{pmatrix} \\longrightarrow \\begin{pmatrix} ie^{i\\theta_{0,1}}e^{i\\phi_{0,1}}\\sin{\\theta_{0,1}} &amp; ie^{i\\theta_{0,1}}\\cos{\\theta_{0,1}}&amp;0&amp;0&amp;0</span>
<span class="sd">        \\\ ie^{i\\theta_{0,1}}e^{i\\phi_{0,1}}\\cos{\\theta_{0,1}} &amp; ie^{i\\theta_{0,1}}\\sin{\\theta_{0,1}}&amp;0&amp;0&amp;0 \\\ 0&amp;0&amp;ie^{i\\theta_{2,3}}e^{i\\phi_{2,3}}\\sin{\\theta_{2,3}} &amp; ie^{i\\theta_{2,3}}\\cos{\\theta_{2,3}}&amp;0</span>
<span class="sd">        \\\ 0&amp;0&amp;ie^{i\\theta_{2,3}}e^{i\\phi_{2,3}}\\cos{\\theta_{2,3}} &amp; ie^{i\\theta_{2,3}}\\sin{\\theta_{2,3}}&amp;0 \\\ 0&amp;0&amp;0&amp;0&amp;1 \\end{pmatrix}. $$</span>

<span class="sd">        Args:</span>
<span class="sd">            placementSpecifier: A placeholder that instructs the function where to begin inserting MZI transfer matrices</span>
<span class="sd">            phis: A 1D array of length `(m - placementSpecifier) // 2` that includes the $\\phi$ phase shifts for each MZI in the column</span>
<span class="sd">            twothetas: A 1D array of length `(m - placementSpecifier) // 2` that includes the $2\\theta$ phase shifts for each MZI in the column</span>
<span class="sd">            SRs: A 1D array of length `2 * (m - placementSpecifier // 2)` that includes the directional coupler splitting ratios, $t$, for each MZI in the column</span>
<span class="sd">            alphas: A 1D array of length `m` that includes the fractions of light lost, $\\alpha$, for each optical mode in the column</span>

<span class="sd">        Returns:</span>
<span class="sd">            An $m\\times m$ 2D array that represents the transformation yielded by a column of MZIs</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Place the MZI transfer matrices $T_{p,q}$ as blocks along the diagonal from (p,p) to (q,q)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">mzi_column</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">placementSpecifier</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
            <span class="n">mzi_column</span><span class="p">[</span><span class="n">p</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">p</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mzi</span><span class="p">(</span><span class="n">phis</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">twothetas</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">SR1</span><span class="o">=</span><span class="n">SRs</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">SR2</span><span class="o">=</span><span class="n">SRs</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">2</span>

        <span class="c1"># Multiply the losses for each optical mode in the column</span>
        <span class="n">mzi_column</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">alphas</span><span class="p">)),</span> <span class="n">mzi_column</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mzi_column</span>

    <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Encode a MZI mesh in the Clements configuration from an array of phase shifts.</span>

<span class="sd">        Using Clements encoding, any $m\\times m$ unitary matrix can be generated by</span>
<span class="sd">        multiplying a set of block diagonal unitary transformations</span>
<span class="sd">        $\\mathbf{T}_{p,q}(\\phi,\\theta)$ with the $m\\times m$ identity matrix in a</span>
<span class="sd">        specific order. Each transformation, $\\mathbf{T}_{p,q}$, features a $2\\times 2$</span>
<span class="sd">        block that acts only on adjacent modes $p,q : p = q-1$. This $2\\times 2$ block is</span>
<span class="sd">        computed according to the diagram displayed below where $\\phi$ and $2\\theta$ are</span>
<span class="sd">        phase shifters, applied to mode $p$ only, and the intersections are 50:50 directional</span>
<span class="sd">        couplers (ideally, otherwise with splitting ratio $t$).</span>

<span class="sd">        &lt;p align=&quot;center&quot;&gt;</span>
<span class="sd">        &lt;img width=&quot;500&quot; src=&quot;img/mzi.png&quot;&gt;</span>
<span class="sd">        &lt;/p&gt;</span>

<span class="sd">        Transformations, $\\mathbf{T}_{p,q}$, are applied in each iteration of the loop. When</span>
<span class="sd">        the loop counter is even, `placementSpecifier = 0` such that the transformations for</span>
<span class="sd">        the first two optical modes and each consecutive adjacent pair are generated. For</span>
<span class="sd">        example, if $m = 5$, then the initial iteration will generate and apply $\\mathbf{T}_{1,2}$,</span>
<span class="sd">        $\\mathbf{T}_{3,4}$, while the second iteration (`placementSpecifier = 1`) produces</span>
<span class="sd">        $\\mathbf{T}_{2,3}$, $\\mathbf{T}_{4,5}$. Since the phases are input in a 1D array,</span>
<span class="sd">        it must be accessed specifically when generating the transformations. Each phase shift</span>
<span class="sd">        column ($\\phi$ or $2\\theta$) requires as many phase parameters as there are</span>
<span class="sd">        transformations to generate in a given loop iteration. Thus, the input array is</span>
<span class="sd">        accessed according to the phase shifts per column (`pspc`) calculation which depends</span>
<span class="sd">        on $m$ and the `placementSpecifier` for the particular iteration. The matrix</span>
<span class="sd">        multiplications take place according to the order (left to right) in the figure above,</span>
<span class="sd">        Therefore, as an example, if a given iteration constructs two transformations,</span>
<span class="sd">        $\\mathbf{T}_{1,2}$ and $\\mathbf{T}_{3,4}$, the phase shifts must be ordered as</span>
<span class="sd">        $\\phi_{1,2}$, $\\phi_{3,4}$, $2\\theta_{1,2}$, $2\\theta_{3,4}$.</span>

<span class="sd">        By applying all transformations in the specified order, followed by a column of output</span>
<span class="sd">        phase shifters on each mode, a rectangular mesh that represents the full $m \\times m$</span>
<span class="sd">        single-photon unitary matrix is generated. This is displayed below, where each cross</span>
<span class="sd">        is a MZI.</span>

<span class="sd">        &lt;p align=&quot;center&quot;&gt;</span>
<span class="sd">        &lt;img width=&quot;500&quot; src=&quot;img/mzi_mesh.png&quot;&gt;</span>
<span class="sd">        &lt;/p&gt;</span>

<span class="sd">        Mathematically, this procedure takes the form,</span>

<span class="sd">        $$ \\mathbf{U}(\\boldsymbol{\\phi}, \\boldsymbol{\\theta}) = \\mathbf{D}\\prod_{(p,q)\\in R}\\mathbf{T}_{p,q}(\\phi,\\theta), $$</span>

<span class="sd">        where $R$ is the sequence of the $\\frac{1}{2}m(m-1)$ two-mode transformations, and</span>
<span class="sd">        $\\phi$, $\\theta$ are elements of the corresponding vectors $\\boldsymbol{\\phi}$,</span>
<span class="sd">        $\\boldsymbol{\\theta}$ that are selected according to the sequence, and $\\mathbf{D}$</span>
<span class="sd">        is a diagonal $m\\times m$ matrix that is representative of the column of output</span>
<span class="sd">        phase shifters.</span>

<span class="sd">        It is termed a &quot;single-photon&quot; unitary as it is a representation only in the Fock</span>
<span class="sd">        basis of $m$ modes when $n = 1$. To obtain the &quot;multi-photon&quot; unitary, a</span>
<span class="sd">        transformation must be applied (see [AA](aa.md)).</span>

<span class="sd">        Returns:</span>
<span class="sd">            An $m\\times m$ 2D array representative of the linear unitary transformation, $\\mathbf{U}(\\boldsymbol{\\phi}, \\boldsymbol{\\theta})$, enacted by the Clements mesh</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Initialize single-photon unitary as an m x m identity matrix</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

            <span class="n">indP</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">indSR</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">indA</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">):</span>
                <span class="c1"># Compute placement specifier to act on specific adjacent modes</span>
                <span class="n">placementSpecifier</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span>

                <span class="c1"># Compute number of phase shifts, of each respective type, per column</span>
                <span class="n">pspc</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">-</span> <span class="n">placementSpecifier</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

                <span class="c1"># Compute number of splitting ratios per column</span>
                <span class="n">srpc</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pspc</span>

                <span class="c1"># Compute the column of Tpq transformations</span>
                <span class="n">Tpq_column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mzi_column</span><span class="p">(</span>
                    <span class="n">placementSpecifier</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">indP</span> <span class="p">:</span> <span class="n">indP</span> <span class="o">+</span> <span class="n">pspc</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">indP</span> <span class="o">+</span> <span class="n">pspc</span> <span class="p">:</span> <span class="n">indP</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pspc</span><span class="p">)],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">SR</span><span class="p">[</span><span class="n">indSR</span> <span class="p">:</span> <span class="n">indSR</span> <span class="o">+</span> <span class="n">srpc</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">indA</span> <span class="p">:</span> <span class="n">indA</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">],</span>
                <span class="p">)</span>

                <span class="c1"># Multiply the column of Tpq transformations with the previous single-photon unitary</span>
                <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Tpq_column</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>

                <span class="c1"># Adjust indices for parameter access</span>
                <span class="n">indP</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pspc</span>
                <span class="n">indSR</span> <span class="o">+=</span> <span class="n">srpc</span>
                <span class="n">indA</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span>

            <span class="c1"># Finish encoding by multiplying the output phase shifts to each optical mode, including loss</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">indA</span> <span class="p">:</span> <span class="n">indA</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">])</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">indP</span> <span class="p">:</span> <span class="n">indP</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">])</span> <span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">U</span>

        <span class="c1"># If m = 2, the mesh is a MZI followed by output phase shifters</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Extract MZI phase shifts, splitting ratios, and fractions of light lost in each arm</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">twotheta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">SR1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">SR2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SR</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">alpha_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">alpha_low</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Compute the MZI transfer matrix to build the single-photon unitary</span>
            <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mzi</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">twotheta</span><span class="p">,</span> <span class="n">SR1</span><span class="o">=</span><span class="n">SR1</span><span class="p">,</span> <span class="n">SR2</span><span class="o">=</span><span class="n">SR2</span><span class="p">,</span> <span class="n">alpha_up</span><span class="o">=</span><span class="n">alpha_up</span><span class="p">,</span> <span class="n">alpha_low</span><span class="o">=</span><span class="n">alpha_low</span><span class="p">)</span>

            <span class="c1"># Finish encoding by multiplying the output phase shifts, with their respective losses</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="mi">2</span><span class="p">::])</span> <span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">U</span>

    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">U</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform Clements decomposition on a square $m\\times m$ unitary matrix.</span>

<span class="sd">        Given some linear $m\\times m$ unitary transformation, where $m$ is the number</span>
<span class="sd">        of optical modes, this method performs Clements decomposition to determine the</span>
<span class="sd">        phase shifts ($\\phi, \\theta$) for each MZI such that the mesh performs this</span>
<span class="sd">        transformation. Once determined, the phases are saved to the `phases` attribute.</span>
<span class="sd">        For more details on the decomposition procedure, see [W. R. Clements *et al*.,</span>
<span class="sd">        &quot;Optimal design for universal multiport interferometers&quot;, *Optica* **3**,</span>
<span class="sd">        1460-1465 (2016)](https://doi.org/10.1364/OPTICA.3.001460). This method is</span>
<span class="sd">        adapted from the [Interferometer](https://github.com/clementsw/interferometer)</span>
<span class="sd">        repository.</span>

<span class="sd">        The main difference between this implementation and the original by Clements</span>
<span class="sd">        *et al*. is the form of the MZI transfer matrix assumed. In the ideal case, a</span>
<span class="sd">        MZI is described by,</span>

<span class="sd">        $$ ie^{i\\theta}\\begin{pmatrix} e^{i\\phi}\\sin{\\theta} &amp; \\cos{\\theta} \\\ e^{i\\phi}\\cos{\\theta} &amp; -\\sin{\\theta} \\end{pmatrix}. $$</span>

<span class="sd">        Clements *et al*. chose to perform a transformation, $\\theta\\to\\frac{\\pi}{2}-\\theta$,</span>
<span class="sd">        $\\phi\\to\\phi+\\pi$, to achieve the form,</span>

<span class="sd">        $$ e^{-i\\theta}\\begin{pmatrix} e^{i\\phi}\\cos{\\theta} &amp; -\\sin{\\theta} \\\ e^{i\\phi}\\sin{\\theta} &amp; \\cos{\\theta} \\end{pmatrix}. $$</span>

<span class="sd">        Here, this transformation is undone by applying the inverse transformation,</span>
<span class="sd">        $\\theta\\to\\frac{\\pi}{2}-\\theta$, $\\phi\\to\\phi+\\pi$, at each stage of</span>
<span class="sd">        the decomposition procedure. This function concludes by arranging the phase</span>
<span class="sd">        shifts as required for the encoding scheme specified in `encode`.</span>

<span class="sd">        Args:</span>
<span class="sd">            U: A 2D $m\\times m$ array to perform Clements decomposition on</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Initialize lists of MZIs and T_{p,q} applied from the left</span>
        <span class="n">MZIs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">T_lefts</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Need to zero out m - 1 diagonal sections from the matrix U</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># For even i, multiply from the right</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># Store modes that T acts on</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span>
                    <span class="n">q</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>

                    <span class="c1"># Compute phi, theta to 0 out matrix element</span>
                    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
                    <span class="n">twotheta</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">theta</span>

                    <span class="c1"># From phi, theta, construct T_{p,q}^{-1}, then right-multiply</span>
                    <span class="n">T_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                    <span class="n">T_right</span><span class="p">[</span><span class="n">p</span> <span class="p">:</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span> <span class="p">:</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mzi</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">twotheta</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">T_right</span><span class="p">)</span>

                    <span class="c1"># Append MZI to list, noting modes and phases</span>
                    <span class="n">MZIs</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;pq&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="s2">&quot;phi&quot;</span><span class="p">:</span> <span class="n">phi</span><span class="p">,</span> <span class="s2">&quot;twotheta&quot;</span><span class="p">:</span> <span class="n">twotheta</span><span class="p">})</span>

            <span class="c1"># For odd i, multiply from the left</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># Store modes that T acts on</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">2</span>
                    <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>

                    <span class="c1"># Compute phi, theta to 0 out matrix element</span>
                    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="o">-</span><span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span>
                    <span class="n">twotheta</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">theta</span>

                    <span class="c1"># From phi, theta, construct T_{p,q}, then left-multiply</span>
                    <span class="n">T_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                    <span class="n">T_left</span><span class="p">[</span><span class="n">p</span> <span class="p">:</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span> <span class="p">:</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mzi</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">twotheta</span><span class="p">)</span>
                    <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T_left</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>

                    <span class="c1"># Append left-multiplying T_{p,q} to list, noting modes and phases</span>
                    <span class="n">T_lefts</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;pq&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="s2">&quot;phi&quot;</span><span class="p">:</span> <span class="n">phi</span><span class="p">,</span> <span class="s2">&quot;twotheta&quot;</span><span class="p">:</span> <span class="n">twotheta</span><span class="p">})</span>

        <span class="c1"># Check that the resultant matrix, $D$, is diagonal</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">U</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">)),</span> <span class="s2">&quot;Decomposition did not yield a diagonal matrix D.&quot;</span>

        <span class="c1"># Rearrange the transformations to match the encoding scheme</span>
        <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">T_lefts</span><span class="p">):</span>
            <span class="c1"># Extract modes, phases for the T_{p,q}</span>
            <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="s2">&quot;pq&quot;</span><span class="p">]</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">]</span>
            <span class="n">twotheta</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="s2">&quot;twotheta&quot;</span><span class="p">]</span>

            <span class="c1"># Construct T_{p,q}^{-1}, then left-multiply</span>
            <span class="n">T_left_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">T_left_inv</span><span class="p">[</span><span class="n">p</span> <span class="p">:</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span> <span class="p">:</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mzi</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">twotheta</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T_left_inv</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>

            <span class="c1"># Compute phi, theta that allow T_{p,q}^{-1} to be multiplied on the right</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">/</span> <span class="n">U</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="p">])</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">/</span> <span class="n">U</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="p">]))</span>
            <span class="n">twotheta</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">theta</span>

            <span class="c1"># From phi, theta, construct T_{p,q}^{-1}, then right-multiply</span>
            <span class="n">T_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">T_right</span><span class="p">[</span><span class="n">p</span> <span class="p">:</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span> <span class="p">:</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mzi</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">twotheta</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">T_right</span><span class="p">)</span>

            <span class="c1"># Append MZI to list, noting modes and phases</span>
            <span class="n">MZIs</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;pq&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="s2">&quot;phi&quot;</span><span class="p">:</span> <span class="n">phi</span><span class="p">,</span> <span class="s2">&quot;twotheta&quot;</span><span class="p">:</span> <span class="n">twotheta</span><span class="p">})</span>

        <span class="c1"># Check that the resultant matrix, $D&#39;$, is diagonal</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">U</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">)),</span> <span class="s2">&quot;Decomposition did not yield a diagonal matrix D&#39;.&quot;</span>

        <span class="c1"># Compute output phases from the diagonal of the resultant matrix U</span>
        <span class="n">out_phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">U</span><span class="p">))</span>

        <span class="c1"># Sort the MZIs by mode pair and the order in which they must be applied</span>
        <span class="n">sorted_MZIs</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">MZI</span> <span class="ow">in</span> <span class="n">MZIs</span><span class="p">:</span>
            <span class="n">sorted_MZIs</span><span class="p">[</span><span class="n">MZI</span><span class="p">[</span><span class="s2">&quot;pq&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MZI</span><span class="p">)</span>

        <span class="c1"># Arrange all phase shifts in the order required by the encoding scheme</span>
        <span class="n">indP</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">):</span>
            <span class="n">placementSpecifier</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span>
            <span class="n">pspc</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">-</span> <span class="n">placementSpecifier</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">placementSpecifier</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
                <span class="n">MZI</span> <span class="o">=</span> <span class="n">sorted_MZIs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">phases</span><span class="p">[</span><span class="n">indP</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">MZI</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">]</span>
                <span class="n">phases</span><span class="p">[</span><span class="n">indP</span> <span class="o">+</span> <span class="n">pspc</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">MZI</span><span class="p">[</span><span class="s2">&quot;twotheta&quot;</span><span class="p">]</span>

            <span class="n">indP</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pspc</span>
        <span class="n">phases</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="p">:</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">out_phases</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">phases</span> <span class="o">=</span> <span class="n">phases</span>
</code></pre></div></td></tr></table></div>
        </details>

  

  <div class="doc doc-children">









<div class="doc doc-object doc-function">



<h3 id="quotonic.clements.Mesh.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">numModes</span><span class="p">,</span> <span class="n">alphaWG</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">std_alphaWG</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">std_SR</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ellMZI</span><span class="o">=</span><span class="mf">0.028668</span><span class="p">,</span> <span class="n">ellPS</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">ellF</span><span class="o">=</span><span class="mf">0.028668</span><span class="p">)</span></code>

<a href="#quotonic.clements.Mesh.__init__" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Initialization of a MZI mesh arranged in the Clements configuration.</p>
<p>The properties of the mesh are first saved, and its phase shifts are initialized as zeroes. If losses
are provided, then component-by-component loss probabilities are computed and stored either by
selecting them randomly from a normal distribution (if a standard deviation is provided), or by
computing the uniform losses for each component. In either case, the mean fraction of light lost,
<span class="arithmatex">\(\alpha\)</span>, is given by,</p>
<div class="arithmatex">\[ \alpha = 1 - 10^{-\frac{\alpha_\mathrm{WG}\ell}{10}}, \]</div>
<p>for a given component of charactersitic length <span class="arithmatex">\(\ell\)</span> and photon propagation losses
in <span class="arithmatex">\(\text{dB}/\text{cm}\)</span> of <span class="arithmatex">\(\alpha_\mathrm{WG}\)</span>, The loss probabilities are concatenated
into a single 1D array ordered as follows: loss in each optical mode for MZI column 1, loss in each
optical mode for MZI column 2, ..., loss in each optical mode for output phase shift column. If a
standard deviation on the directional coupler splitting ratios is provided, then specific splitting
ratios are selected randomly from a normal distribution for each directional coupler in the mesh.
Similarly, these are concatenated into a single 1D array ordered as follows: ratios for the two
directional couplers in the top MZI of column 1, ..., ratios for the two directional couplers in
the bottom MZI of column 1, ratios for the two directional couplers in the top MZI of column 2,
..., ratios for the two directional couplers in the bottom MZI of column 2, etc.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>numModes</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Number of optical modes, <span class="arithmatex">\(m\)</span></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>alphaWG</code></td>
          <td>
                <code><span title="typing.Optional">Optional</span>[float]</code>
          </td>
          <td><p>Mean propagation losses, <span class="arithmatex">\(\alpha_\mathrm{WG}\)</span>, in <span class="arithmatex">\(\text{dB}/\text{cm}\)</span></p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>std_alphaWG</code></td>
          <td>
                <code><span title="typing.Optional">Optional</span>[float]</code>
          </td>
          <td><p>Standard deviation of the propagation losses, <span class="arithmatex">\(\alpha_\mathrm{WG}\)</span>, in <span class="arithmatex">\(\text{dB}/\text{cm}\)</span></p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>std_SR</code></td>
          <td>
                <code><span title="typing.Optional">Optional</span>[float]</code>
          </td>
          <td><p>Standard deviation of the directional coupler splitting ratio, <span class="arithmatex">\(t\)</span></p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>ellMZI</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Characteristic length of a MZI, <span class="arithmatex">\(\ell_\mathrm{MZI}\)</span>, in <span class="arithmatex">\(\text{cm}\)</span></p></td>
          <td>
                <code>0.028668</code>
          </td>
        </tr>
        <tr>
          <td><code>ellPS</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Characteristic length of a phase shifter, <span class="arithmatex">\(\ell_\mathrm{PS}\)</span>, in <span class="arithmatex">\(\text{cm}\)</span></p></td>
          <td>
                <code>0.005</code>
          </td>
        </tr>
        <tr>
          <td><code>ellF</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Characteristic length of a flat section in parallel with a MZI, <span class="arithmatex">\(\ell_\mathrm{F}\)</span>, in <span class="arithmatex">\(\text{cm}\)</span></p></td>
          <td>
                <code>0.028668</code>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>quotonic/clements.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">numModes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">alphaWG</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">std_alphaWG</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">std_SR</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ellMZI</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.028668</span><span class="p">,</span>
    <span class="n">ellPS</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0050</span><span class="p">,</span>
    <span class="n">ellF</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.028668</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialization of a MZI mesh arranged in the Clements configuration.</span>

<span class="sd">    The properties of the mesh are first saved, and its phase shifts are initialized as zeroes. If losses</span>
<span class="sd">    are provided, then component-by-component loss probabilities are computed and stored either by</span>
<span class="sd">    selecting them randomly from a normal distribution (if a standard deviation is provided), or by</span>
<span class="sd">    computing the uniform losses for each component. In either case, the mean fraction of light lost,</span>
<span class="sd">    $\\alpha$, is given by,</span>

<span class="sd">    $$ \\alpha = 1 - 10^{-\\frac{\\alpha_\\mathrm{WG}\\ell}{10}}, $$</span>

<span class="sd">    for a given component of charactersitic length $\\ell$ and photon propagation losses</span>
<span class="sd">    in $\\text{dB}/\\text{cm}$ of $\\alpha_\\mathrm{WG}$, The loss probabilities are concatenated</span>
<span class="sd">    into a single 1D array ordered as follows: loss in each optical mode for MZI column 1, loss in each</span>
<span class="sd">    optical mode for MZI column 2, ..., loss in each optical mode for output phase shift column. If a</span>
<span class="sd">    standard deviation on the directional coupler splitting ratios is provided, then specific splitting</span>
<span class="sd">    ratios are selected randomly from a normal distribution for each directional coupler in the mesh.</span>
<span class="sd">    Similarly, these are concatenated into a single 1D array ordered as follows: ratios for the two</span>
<span class="sd">    directional couplers in the top MZI of column 1, ..., ratios for the two directional couplers in</span>
<span class="sd">    the bottom MZI of column 1, ratios for the two directional couplers in the top MZI of column 2,</span>
<span class="sd">    ..., ratios for the two directional couplers in the bottom MZI of column 2, etc.</span>

<span class="sd">    Args:</span>
<span class="sd">        numModes: Number of optical modes, $m$</span>
<span class="sd">        alphaWG: Mean propagation losses, $\\alpha_\\mathrm{WG}$, in $\\text{dB}/\\text{cm}$</span>
<span class="sd">        std_alphaWG: Standard deviation of the propagation losses, $\\alpha_\\mathrm{WG}$, in $\\text{dB}/\\text{cm}$</span>
<span class="sd">        std_SR: Standard deviation of the directional coupler splitting ratio, $t$</span>
<span class="sd">        ellMZI: Characteristic length of a MZI, $\\ell_\\mathrm{MZI}$, in $\\text{cm}$</span>
<span class="sd">        ellPS: Characteristic length of a phase shifter, $\\ell_\\mathrm{PS}$, in $\\text{cm}$</span>
<span class="sd">        ellF: Characteristic length of a flat section in parallel with a MZI, $\\ell_\\mathrm{F}$, in $\\text{cm}$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Store the provided properties of the mesh and initialize the phases</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">=</span> <span class="n">numModes</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">alphaWG</span> <span class="o">=</span> <span class="n">alphaWG</span>  <span class="c1"># dB/cm</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">std_alphaWG</span> <span class="o">=</span> <span class="n">std_alphaWG</span>  <span class="c1"># dB/cm</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">std_SR</span> <span class="o">=</span> <span class="n">std_SR</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ellMZI</span> <span class="o">=</span> <span class="n">ellMZI</span>  <span class="c1"># cm</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ellPS</span> <span class="o">=</span> <span class="n">ellPS</span>  <span class="c1"># cm</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ellF</span> <span class="o">=</span> <span class="n">ellF</span>  <span class="c1"># cm</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numModes</span> <span class="o">*</span> <span class="n">numModes</span><span class="p">)</span>

    <span class="c1"># If losses are provided, compute the loss probability contributed by each component in the mesh</span>
    <span class="k">if</span> <span class="n">alphaWG</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># If losses are non-uniform, loss probabilities are selected randomly from a normal distribution</span>
        <span class="k">if</span> <span class="n">std_alphaWG</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># MZI losses</span>
            <span class="n">mu_alphaMZI</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">ellMZI</span> <span class="o">*</span> <span class="n">alphaWG</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">sigma_alphaMZI</span> <span class="o">=</span> <span class="n">std_alphaWG</span> <span class="o">*</span> <span class="n">ellMZI</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">alphaWG</span> <span class="o">*</span> <span class="n">ellMZI</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span>
            <span class="n">alphaMZI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">mu_alphaMZI</span><span class="p">,</span> <span class="n">sigma_alphaMZI</span><span class="p">,</span> <span class="n">numModes</span> <span class="o">*</span> <span class="p">(</span><span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

            <span class="c1"># Phase shifter losses</span>
            <span class="n">mu_alphaPS</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">ellPS</span> <span class="o">*</span> <span class="n">alphaWG</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">sigma_alphaPS</span> <span class="o">=</span> <span class="n">std_alphaWG</span> <span class="o">*</span> <span class="n">ellPS</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">alphaWG</span> <span class="o">*</span> <span class="n">ellPS</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span>
            <span class="n">alphaPS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">mu_alphaPS</span><span class="p">,</span> <span class="n">sigma_alphaPS</span><span class="p">,</span> <span class="n">numModes</span><span class="p">)</span>

            <span class="c1"># Flat section losses</span>
            <span class="n">mu_alphaF</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">ellF</span> <span class="o">*</span> <span class="n">alphaWG</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">sigma_alphaF</span> <span class="o">=</span> <span class="n">std_alphaWG</span> <span class="o">*</span> <span class="n">ellF</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">alphaWG</span> <span class="o">*</span> <span class="n">ellF</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span>
            <span class="n">alphaF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">mu_alphaF</span><span class="p">,</span> <span class="n">sigma_alphaF</span><span class="p">,</span> <span class="n">numModes</span><span class="p">)</span>

        <span class="c1"># If losses are uniform, loss probabilities are computed just once for each component</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alphaMZI</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">ellMZI</span> <span class="o">*</span> <span class="n">alphaWG</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">numModes</span> <span class="o">*</span> <span class="p">(</span><span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">alphaPS</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">ellPS</span> <span class="o">*</span> <span class="n">alphaWG</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">numModes</span><span class="p">)</span>
            <span class="n">alphaF</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">ellF</span> <span class="o">*</span> <span class="n">alphaWG</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">numModes</span><span class="p">)</span>

        <span class="c1"># Arrange the loss probabilities to match the arrangement of the encoding scheme</span>
        <span class="k">if</span> <span class="n">numModes</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alphaMZI</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">alphaPS</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">alphaF</span><span class="p">))</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">indMZI</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">indF</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">numModes</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numModes</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">ind</span> <span class="p">:</span> <span class="n">ind</span> <span class="o">+</span> <span class="n">numModes</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaMZI</span><span class="p">[</span><span class="n">indMZI</span> <span class="p">:</span> <span class="n">indMZI</span> <span class="o">+</span> <span class="n">numModes</span><span class="p">]</span>
                        <span class="n">indMZI</span> <span class="o">+=</span> <span class="n">numModes</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">ind</span> <span class="p">:</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaF</span><span class="p">[</span><span class="n">indF</span> <span class="p">:</span> <span class="n">indF</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">ind</span> <span class="o">+</span> <span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaMZI</span><span class="p">[</span><span class="n">indMZI</span> <span class="p">:</span> <span class="n">indMZI</span> <span class="o">+</span> <span class="n">numModes</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">ind</span> <span class="o">+</span> <span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">ind</span> <span class="o">+</span> <span class="n">numModes</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaF</span><span class="p">[</span><span class="n">indF</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">indF</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
                        <span class="n">indMZI</span> <span class="o">+=</span> <span class="n">numModes</span> <span class="o">-</span> <span class="mi">2</span>
                        <span class="n">indF</span> <span class="o">+=</span> <span class="mi">2</span>
                    <span class="n">ind</span> <span class="o">+=</span> <span class="n">numModes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numModes</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">ind</span> <span class="p">:</span> <span class="n">ind</span> <span class="o">+</span> <span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaMZI</span><span class="p">[</span><span class="n">indMZI</span> <span class="p">:</span> <span class="n">indMZI</span> <span class="o">+</span> <span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">ind</span> <span class="o">+</span> <span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">ind</span> <span class="o">+</span> <span class="n">numModes</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaF</span><span class="p">[</span><span class="n">indF</span> <span class="p">:</span> <span class="n">indF</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">ind</span> <span class="p">:</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaF</span><span class="p">[</span><span class="n">indF</span> <span class="p">:</span> <span class="n">indF</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">ind</span> <span class="o">+</span> <span class="n">numModes</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaMZI</span><span class="p">[</span><span class="n">indMZI</span> <span class="p">:</span> <span class="n">indMZI</span> <span class="o">+</span> <span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">indMZI</span> <span class="o">+=</span> <span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">indF</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">ind</span> <span class="o">+=</span> <span class="n">numModes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alphaMZI</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">alphaPS</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaMZI</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">ind</span><span class="p">::]</span> <span class="o">=</span> <span class="n">alphaPS</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numModes</span> <span class="o">*</span> <span class="p">(</span><span class="n">numModes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># If directional coupler splitting ratios vary, select them randomly from a normal distribution</span>
    <span class="k">if</span> <span class="n">std_SR</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">std_SR</span><span class="p">,</span> <span class="n">numModes</span> <span class="o">*</span> <span class="p">(</span><span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="c1"># If directional coupler splitting ratios do not vary, then they are all 50:50</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SR</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">numModes</span> <span class="o">*</span> <span class="p">(</span><span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="quotonic.clements.Mesh.decode" class="doc doc-heading">
<code class="highlight language-python"><span class="n">decode</span><span class="p">(</span><span class="n">U</span><span class="p">)</span></code>

<a href="#quotonic.clements.Mesh.decode" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Perform Clements decomposition on a square <span class="arithmatex">\(m\times m\)</span> unitary matrix.</p>
<p>Given some linear <span class="arithmatex">\(m\times m\)</span> unitary transformation, where <span class="arithmatex">\(m\)</span> is the number
of optical modes, this method performs Clements decomposition to determine the
phase shifts (<span class="arithmatex">\(\phi, \theta\)</span>) for each MZI such that the mesh performs this
transformation. Once determined, the phases are saved to the <code>phases</code> attribute.
For more details on the decomposition procedure, see <a href="https://doi.org/10.1364/OPTICA.3.001460">W. R. Clements <em>et al</em>.,
"Optimal design for universal multiport interferometers", <em>Optica</em> <strong>3</strong>,
1460-1465 (2016)</a>. This method is
adapted from the <a href="https://github.com/clementsw/interferometer">Interferometer</a>
repository.</p>
<p>The main difference between this implementation and the original by Clements
<em>et al</em>. is the form of the MZI transfer matrix assumed. In the ideal case, a
MZI is described by,</p>
<div class="arithmatex">\[ ie^{i\theta}\begin{pmatrix} e^{i\phi}\sin{\theta} &amp; \cos{\theta} \\ e^{i\phi}\cos{\theta} &amp; -\sin{\theta} \end{pmatrix}. \]</div>
<p>Clements <em>et al</em>. chose to perform a transformation, <span class="arithmatex">\(\theta\to\frac{\pi}{2}-\theta\)</span>,
<span class="arithmatex">\(\phi\to\phi+\pi\)</span>, to achieve the form,</p>
<div class="arithmatex">\[ e^{-i\theta}\begin{pmatrix} e^{i\phi}\cos{\theta} &amp; -\sin{\theta} \\ e^{i\phi}\sin{\theta} &amp; \cos{\theta} \end{pmatrix}. \]</div>
<p>Here, this transformation is undone by applying the inverse transformation,
<span class="arithmatex">\(\theta\to\frac{\pi}{2}-\theta\)</span>, <span class="arithmatex">\(\phi\to\phi+\pi\)</span>, at each stage of
the decomposition procedure. This function concludes by arranging the phase
shifts as required for the encoding scheme specified in <code>encode</code>.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>U</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A 2D <span class="arithmatex">\(m\times m\)</span> array to perform Clements decomposition on</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>quotonic/clements.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">U</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform Clements decomposition on a square $m\\times m$ unitary matrix.</span>

<span class="sd">    Given some linear $m\\times m$ unitary transformation, where $m$ is the number</span>
<span class="sd">    of optical modes, this method performs Clements decomposition to determine the</span>
<span class="sd">    phase shifts ($\\phi, \\theta$) for each MZI such that the mesh performs this</span>
<span class="sd">    transformation. Once determined, the phases are saved to the `phases` attribute.</span>
<span class="sd">    For more details on the decomposition procedure, see [W. R. Clements *et al*.,</span>
<span class="sd">    &quot;Optimal design for universal multiport interferometers&quot;, *Optica* **3**,</span>
<span class="sd">    1460-1465 (2016)](https://doi.org/10.1364/OPTICA.3.001460). This method is</span>
<span class="sd">    adapted from the [Interferometer](https://github.com/clementsw/interferometer)</span>
<span class="sd">    repository.</span>

<span class="sd">    The main difference between this implementation and the original by Clements</span>
<span class="sd">    *et al*. is the form of the MZI transfer matrix assumed. In the ideal case, a</span>
<span class="sd">    MZI is described by,</span>

<span class="sd">    $$ ie^{i\\theta}\\begin{pmatrix} e^{i\\phi}\\sin{\\theta} &amp; \\cos{\\theta} \\\ e^{i\\phi}\\cos{\\theta} &amp; -\\sin{\\theta} \\end{pmatrix}. $$</span>

<span class="sd">    Clements *et al*. chose to perform a transformation, $\\theta\\to\\frac{\\pi}{2}-\\theta$,</span>
<span class="sd">    $\\phi\\to\\phi+\\pi$, to achieve the form,</span>

<span class="sd">    $$ e^{-i\\theta}\\begin{pmatrix} e^{i\\phi}\\cos{\\theta} &amp; -\\sin{\\theta} \\\ e^{i\\phi}\\sin{\\theta} &amp; \\cos{\\theta} \\end{pmatrix}. $$</span>

<span class="sd">    Here, this transformation is undone by applying the inverse transformation,</span>
<span class="sd">    $\\theta\\to\\frac{\\pi}{2}-\\theta$, $\\phi\\to\\phi+\\pi$, at each stage of</span>
<span class="sd">    the decomposition procedure. This function concludes by arranging the phase</span>
<span class="sd">    shifts as required for the encoding scheme specified in `encode`.</span>

<span class="sd">    Args:</span>
<span class="sd">        U: A 2D $m\\times m$ array to perform Clements decomposition on</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Initialize lists of MZIs and T_{p,q} applied from the left</span>
    <span class="n">MZIs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">T_lefts</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Need to zero out m - 1 diagonal sections from the matrix U</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># For even i, multiply from the right</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># Store modes that T acts on</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="c1"># Compute phi, theta to 0 out matrix element</span>
                <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
                <span class="n">twotheta</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">theta</span>

                <span class="c1"># From phi, theta, construct T_{p,q}^{-1}, then right-multiply</span>
                <span class="n">T_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="n">T_right</span><span class="p">[</span><span class="n">p</span> <span class="p">:</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span> <span class="p">:</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mzi</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">twotheta</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">T_right</span><span class="p">)</span>

                <span class="c1"># Append MZI to list, noting modes and phases</span>
                <span class="n">MZIs</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;pq&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="s2">&quot;phi&quot;</span><span class="p">:</span> <span class="n">phi</span><span class="p">,</span> <span class="s2">&quot;twotheta&quot;</span><span class="p">:</span> <span class="n">twotheta</span><span class="p">})</span>

        <span class="c1"># For odd i, multiply from the left</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># Store modes that T acts on</span>
                <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">2</span>
                <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="c1"># Compute phi, theta to 0 out matrix element</span>
                <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="o">-</span><span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">U</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span>
                <span class="n">twotheta</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">theta</span>

                <span class="c1"># From phi, theta, construct T_{p,q}, then left-multiply</span>
                <span class="n">T_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="n">T_left</span><span class="p">[</span><span class="n">p</span> <span class="p">:</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span> <span class="p">:</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mzi</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">twotheta</span><span class="p">)</span>
                <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T_left</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>

                <span class="c1"># Append left-multiplying T_{p,q} to list, noting modes and phases</span>
                <span class="n">T_lefts</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;pq&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="s2">&quot;phi&quot;</span><span class="p">:</span> <span class="n">phi</span><span class="p">,</span> <span class="s2">&quot;twotheta&quot;</span><span class="p">:</span> <span class="n">twotheta</span><span class="p">})</span>

    <span class="c1"># Check that the resultant matrix, $D$, is diagonal</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">U</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">)),</span> <span class="s2">&quot;Decomposition did not yield a diagonal matrix D.&quot;</span>

    <span class="c1"># Rearrange the transformations to match the encoding scheme</span>
    <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">T_lefts</span><span class="p">):</span>
        <span class="c1"># Extract modes, phases for the T_{p,q}</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="s2">&quot;pq&quot;</span><span class="p">]</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">]</span>
        <span class="n">twotheta</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="s2">&quot;twotheta&quot;</span><span class="p">]</span>

        <span class="c1"># Construct T_{p,q}^{-1}, then left-multiply</span>
        <span class="n">T_left_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">T_left_inv</span><span class="p">[</span><span class="n">p</span> <span class="p">:</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span> <span class="p">:</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mzi</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">twotheta</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T_left_inv</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>

        <span class="c1"># Compute phi, theta that allow T_{p,q}^{-1} to be multiplied on the right</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">/</span> <span class="n">U</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="p">])</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">/</span> <span class="n">U</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="p">]))</span>
        <span class="n">twotheta</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">theta</span>

        <span class="c1"># From phi, theta, construct T_{p,q}^{-1}, then right-multiply</span>
        <span class="n">T_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">T_right</span><span class="p">[</span><span class="n">p</span> <span class="p">:</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span> <span class="p">:</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mzi</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">twotheta</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">T_right</span><span class="p">)</span>

        <span class="c1"># Append MZI to list, noting modes and phases</span>
        <span class="n">MZIs</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;pq&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="s2">&quot;phi&quot;</span><span class="p">:</span> <span class="n">phi</span><span class="p">,</span> <span class="s2">&quot;twotheta&quot;</span><span class="p">:</span> <span class="n">twotheta</span><span class="p">})</span>

    <span class="c1"># Check that the resultant matrix, $D&#39;$, is diagonal</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">U</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">)),</span> <span class="s2">&quot;Decomposition did not yield a diagonal matrix D&#39;.&quot;</span>

    <span class="c1"># Compute output phases from the diagonal of the resultant matrix U</span>
    <span class="n">out_phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">U</span><span class="p">))</span>

    <span class="c1"># Sort the MZIs by mode pair and the order in which they must be applied</span>
    <span class="n">sorted_MZIs</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">MZI</span> <span class="ow">in</span> <span class="n">MZIs</span><span class="p">:</span>
        <span class="n">sorted_MZIs</span><span class="p">[</span><span class="n">MZI</span><span class="p">[</span><span class="s2">&quot;pq&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MZI</span><span class="p">)</span>

    <span class="c1"># Arrange all phase shifts in the order required by the encoding scheme</span>
    <span class="n">indP</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">):</span>
        <span class="n">placementSpecifier</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span>
        <span class="n">pspc</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">-</span> <span class="n">placementSpecifier</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">placementSpecifier</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
            <span class="n">MZI</span> <span class="o">=</span> <span class="n">sorted_MZIs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">phases</span><span class="p">[</span><span class="n">indP</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">MZI</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">]</span>
            <span class="n">phases</span><span class="p">[</span><span class="n">indP</span> <span class="o">+</span> <span class="n">pspc</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">MZI</span><span class="p">[</span><span class="s2">&quot;twotheta&quot;</span><span class="p">]</span>

        <span class="n">indP</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pspc</span>
    <span class="n">phases</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="p">:</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">out_phases</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">phases</span> <span class="o">=</span> <span class="n">phases</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="quotonic.clements.Mesh.encode" class="doc doc-heading">
<code class="highlight language-python"><span class="n">encode</span><span class="p">()</span></code>

<a href="#quotonic.clements.Mesh.encode" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Encode a MZI mesh in the Clements configuration from an array of phase shifts.</p>
<p>Using Clements encoding, any <span class="arithmatex">\(m\times m\)</span> unitary matrix can be generated by
multiplying a set of block diagonal unitary transformations
<span class="arithmatex">\(\mathbf{T}_{p,q}(\phi,\theta)\)</span> with the <span class="arithmatex">\(m\times m\)</span> identity matrix in a
specific order. Each transformation, <span class="arithmatex">\(\mathbf{T}_{p,q}\)</span>, features a <span class="arithmatex">\(2\times 2\)</span>
block that acts only on adjacent modes <span class="arithmatex">\(p,q : p = q-1\)</span>. This <span class="arithmatex">\(2\times 2\)</span> block is
computed according to the diagram displayed below where <span class="arithmatex">\(\phi\)</span> and <span class="arithmatex">\(2\theta\)</span> are
phase shifters, applied to mode <span class="arithmatex">\(p\)</span> only, and the intersections are 50:50 directional
couplers (ideally, otherwise with splitting ratio <span class="arithmatex">\(t\)</span>).</p>
<p align="center">
<img width="500" src="img/mzi.png">
</p>

<p>Transformations, <span class="arithmatex">\(\mathbf{T}_{p,q}\)</span>, are applied in each iteration of the loop. When
the loop counter is even, <code>placementSpecifier = 0</code> such that the transformations for
the first two optical modes and each consecutive adjacent pair are generated. For
example, if <span class="arithmatex">\(m = 5\)</span>, then the initial iteration will generate and apply <span class="arithmatex">\(\mathbf{T}_{1,2}\)</span>,
<span class="arithmatex">\(\mathbf{T}_{3,4}\)</span>, while the second iteration (<code>placementSpecifier = 1</code>) produces
<span class="arithmatex">\(\mathbf{T}_{2,3}\)</span>, <span class="arithmatex">\(\mathbf{T}_{4,5}\)</span>. Since the phases are input in a 1D array,
it must be accessed specifically when generating the transformations. Each phase shift
column (<span class="arithmatex">\(\phi\)</span> or <span class="arithmatex">\(2\theta\)</span>) requires as many phase parameters as there are
transformations to generate in a given loop iteration. Thus, the input array is
accessed according to the phase shifts per column (<code>pspc</code>) calculation which depends
on <span class="arithmatex">\(m\)</span> and the <code>placementSpecifier</code> for the particular iteration. The matrix
multiplications take place according to the order (left to right) in the figure above,
Therefore, as an example, if a given iteration constructs two transformations,
<span class="arithmatex">\(\mathbf{T}_{1,2}\)</span> and <span class="arithmatex">\(\mathbf{T}_{3,4}\)</span>, the phase shifts must be ordered as
<span class="arithmatex">\(\phi_{1,2}\)</span>, <span class="arithmatex">\(\phi_{3,4}\)</span>, <span class="arithmatex">\(2\theta_{1,2}\)</span>, <span class="arithmatex">\(2\theta_{3,4}\)</span>.</p>
<p>By applying all transformations in the specified order, followed by a column of output
phase shifters on each mode, a rectangular mesh that represents the full <span class="arithmatex">\(m \times m\)</span>
single-photon unitary matrix is generated. This is displayed below, where each cross
is a MZI.</p>
<p align="center">
<img width="500" src="img/mzi_mesh.png">
</p>

<p>Mathematically, this procedure takes the form,</p>
<div class="arithmatex">\[ \mathbf{U}(\boldsymbol{\phi}, \boldsymbol{\theta}) = \mathbf{D}\prod_{(p,q)\in R}\mathbf{T}_{p,q}(\phi,\theta), \]</div>
<p>where <span class="arithmatex">\(R\)</span> is the sequence of the <span class="arithmatex">\(\frac{1}{2}m(m-1)\)</span> two-mode transformations, and
<span class="arithmatex">\(\phi\)</span>, <span class="arithmatex">\(\theta\)</span> are elements of the corresponding vectors <span class="arithmatex">\(\boldsymbol{\phi}\)</span>,
<span class="arithmatex">\(\boldsymbol{\theta}\)</span> that are selected according to the sequence, and <span class="arithmatex">\(\mathbf{D}\)</span>
is a diagonal <span class="arithmatex">\(m\times m\)</span> matrix that is representative of the column of output
phase shifters.</p>
<p>It is termed a "single-photon" unitary as it is a representation only in the Fock
basis of <span class="arithmatex">\(m\)</span> modes when <span class="arithmatex">\(n = 1\)</span>. To obtain the "multi-photon" unitary, a
transformation must be applied (see <a href="aa.html">AA</a>).</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An <span class="arithmatex">\(m\times m\)</span> 2D array representative of the linear unitary transformation, <span class="arithmatex">\(\mathbf{U}(\boldsymbol{\phi}, \boldsymbol{\theta})\)</span>, enacted by the Clements mesh</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>quotonic/clements.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Encode a MZI mesh in the Clements configuration from an array of phase shifts.</span>

<span class="sd">    Using Clements encoding, any $m\\times m$ unitary matrix can be generated by</span>
<span class="sd">    multiplying a set of block diagonal unitary transformations</span>
<span class="sd">    $\\mathbf{T}_{p,q}(\\phi,\\theta)$ with the $m\\times m$ identity matrix in a</span>
<span class="sd">    specific order. Each transformation, $\\mathbf{T}_{p,q}$, features a $2\\times 2$</span>
<span class="sd">    block that acts only on adjacent modes $p,q : p = q-1$. This $2\\times 2$ block is</span>
<span class="sd">    computed according to the diagram displayed below where $\\phi$ and $2\\theta$ are</span>
<span class="sd">    phase shifters, applied to mode $p$ only, and the intersections are 50:50 directional</span>
<span class="sd">    couplers (ideally, otherwise with splitting ratio $t$).</span>

<span class="sd">    &lt;p align=&quot;center&quot;&gt;</span>
<span class="sd">    &lt;img width=&quot;500&quot; src=&quot;img/mzi.png&quot;&gt;</span>
<span class="sd">    &lt;/p&gt;</span>

<span class="sd">    Transformations, $\\mathbf{T}_{p,q}$, are applied in each iteration of the loop. When</span>
<span class="sd">    the loop counter is even, `placementSpecifier = 0` such that the transformations for</span>
<span class="sd">    the first two optical modes and each consecutive adjacent pair are generated. For</span>
<span class="sd">    example, if $m = 5$, then the initial iteration will generate and apply $\\mathbf{T}_{1,2}$,</span>
<span class="sd">    $\\mathbf{T}_{3,4}$, while the second iteration (`placementSpecifier = 1`) produces</span>
<span class="sd">    $\\mathbf{T}_{2,3}$, $\\mathbf{T}_{4,5}$. Since the phases are input in a 1D array,</span>
<span class="sd">    it must be accessed specifically when generating the transformations. Each phase shift</span>
<span class="sd">    column ($\\phi$ or $2\\theta$) requires as many phase parameters as there are</span>
<span class="sd">    transformations to generate in a given loop iteration. Thus, the input array is</span>
<span class="sd">    accessed according to the phase shifts per column (`pspc`) calculation which depends</span>
<span class="sd">    on $m$ and the `placementSpecifier` for the particular iteration. The matrix</span>
<span class="sd">    multiplications take place according to the order (left to right) in the figure above,</span>
<span class="sd">    Therefore, as an example, if a given iteration constructs two transformations,</span>
<span class="sd">    $\\mathbf{T}_{1,2}$ and $\\mathbf{T}_{3,4}$, the phase shifts must be ordered as</span>
<span class="sd">    $\\phi_{1,2}$, $\\phi_{3,4}$, $2\\theta_{1,2}$, $2\\theta_{3,4}$.</span>

<span class="sd">    By applying all transformations in the specified order, followed by a column of output</span>
<span class="sd">    phase shifters on each mode, a rectangular mesh that represents the full $m \\times m$</span>
<span class="sd">    single-photon unitary matrix is generated. This is displayed below, where each cross</span>
<span class="sd">    is a MZI.</span>

<span class="sd">    &lt;p align=&quot;center&quot;&gt;</span>
<span class="sd">    &lt;img width=&quot;500&quot; src=&quot;img/mzi_mesh.png&quot;&gt;</span>
<span class="sd">    &lt;/p&gt;</span>

<span class="sd">    Mathematically, this procedure takes the form,</span>

<span class="sd">    $$ \\mathbf{U}(\\boldsymbol{\\phi}, \\boldsymbol{\\theta}) = \\mathbf{D}\\prod_{(p,q)\\in R}\\mathbf{T}_{p,q}(\\phi,\\theta), $$</span>

<span class="sd">    where $R$ is the sequence of the $\\frac{1}{2}m(m-1)$ two-mode transformations, and</span>
<span class="sd">    $\\phi$, $\\theta$ are elements of the corresponding vectors $\\boldsymbol{\\phi}$,</span>
<span class="sd">    $\\boldsymbol{\\theta}$ that are selected according to the sequence, and $\\mathbf{D}$</span>
<span class="sd">    is a diagonal $m\\times m$ matrix that is representative of the column of output</span>
<span class="sd">    phase shifters.</span>

<span class="sd">    It is termed a &quot;single-photon&quot; unitary as it is a representation only in the Fock</span>
<span class="sd">    basis of $m$ modes when $n = 1$. To obtain the &quot;multi-photon&quot; unitary, a</span>
<span class="sd">    transformation must be applied (see [AA](aa.md)).</span>

<span class="sd">    Returns:</span>
<span class="sd">        An $m\\times m$ 2D array representative of the linear unitary transformation, $\\mathbf{U}(\\boldsymbol{\\phi}, \\boldsymbol{\\theta})$, enacted by the Clements mesh</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Initialize single-photon unitary as an m x m identity matrix</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

        <span class="n">indP</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">indSR</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">indA</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">):</span>
            <span class="c1"># Compute placement specifier to act on specific adjacent modes</span>
            <span class="n">placementSpecifier</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span>

            <span class="c1"># Compute number of phase shifts, of each respective type, per column</span>
            <span class="n">pspc</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">-</span> <span class="n">placementSpecifier</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

            <span class="c1"># Compute number of splitting ratios per column</span>
            <span class="n">srpc</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pspc</span>

            <span class="c1"># Compute the column of Tpq transformations</span>
            <span class="n">Tpq_column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mzi_column</span><span class="p">(</span>
                <span class="n">placementSpecifier</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">indP</span> <span class="p">:</span> <span class="n">indP</span> <span class="o">+</span> <span class="n">pspc</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">indP</span> <span class="o">+</span> <span class="n">pspc</span> <span class="p">:</span> <span class="n">indP</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pspc</span><span class="p">)],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">SR</span><span class="p">[</span><span class="n">indSR</span> <span class="p">:</span> <span class="n">indSR</span> <span class="o">+</span> <span class="n">srpc</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">indA</span> <span class="p">:</span> <span class="n">indA</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Multiply the column of Tpq transformations with the previous single-photon unitary</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Tpq_column</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>

            <span class="c1"># Adjust indices for parameter access</span>
            <span class="n">indP</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pspc</span>
            <span class="n">indSR</span> <span class="o">+=</span> <span class="n">srpc</span>
            <span class="n">indA</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span>

        <span class="c1"># Finish encoding by multiplying the output phase shifts to each optical mode, including loss</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">indA</span> <span class="p">:</span> <span class="n">indA</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">])</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">indP</span> <span class="p">:</span> <span class="n">indP</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">])</span> <span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">U</span>

    <span class="c1"># If m = 2, the mesh is a MZI followed by output phase shifters</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Extract MZI phase shifts, splitting ratios, and fractions of light lost in each arm</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">twotheta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">SR1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">SR2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SR</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">alpha_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">alpha_low</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Compute the MZI transfer matrix to build the single-photon unitary</span>
        <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mzi</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">twotheta</span><span class="p">,</span> <span class="n">SR1</span><span class="o">=</span><span class="n">SR1</span><span class="p">,</span> <span class="n">SR2</span><span class="o">=</span><span class="n">SR2</span><span class="p">,</span> <span class="n">alpha_up</span><span class="o">=</span><span class="n">alpha_up</span><span class="p">,</span> <span class="n">alpha_low</span><span class="o">=</span><span class="n">alpha_low</span><span class="p">)</span>

        <span class="c1"># Finish encoding by multiplying the output phase shifts, with their respective losses</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="mi">2</span><span class="p">::])</span> <span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">U</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="quotonic.clements.Mesh.mzi" class="doc doc-heading">
<code class="highlight language-python"><span class="n">mzi</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">twotheta</span><span class="p">,</span> <span class="n">SR1</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">SR2</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">alpha_up</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">alpha_low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

<a href="#quotonic.clements.Mesh.mzi" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Construct <span class="arithmatex">\(2\times 2\)</span> MZI transfer matrix.</p>
<p>Each MZI, as displayed below, consists of two phase shifters enacting respective
phase shifts <span class="arithmatex">\(\phi\)</span>, <span class="arithmatex">\(\theta\)</span>, and two directional couplers with respective
splitting ratios <span class="arithmatex">\(t_1\)</span>, <span class="arithmatex">\(t_2\)</span> (ideally, <span class="arithmatex">\(t_1 = t_2 = 0.5\)</span>).</p>
<p align="center">
<img width="500" src="img/mzi.png">
</p>

<p>The phase shifter transfer matrices are given by,</p>
<div class="arithmatex">\[ \mathbf{T}_\text{PS}(\phi) = \begin{pmatrix} e^{i\phi} &amp; 0 \\ 0 &amp; 1 \end{pmatrix} \qquad\qquad
\mathbf{T}_\text{PS}(2\theta) = \begin{pmatrix} e^{i2\theta} &amp; 0 \\ 0 &amp; 1 \end{pmatrix}, \]</div>
<p>for phase shifts <span class="arithmatex">\(\phi\)</span> and <span class="arithmatex">\(2\theta\)</span> respectively. The directional coupler
transfer matrix is given by,</p>
<div class="arithmatex">\[ \mathbf{T}_\text{DC}(t) = \begin{pmatrix} \sqrt{t} &amp; i\sqrt{1-t} \\ i\sqrt{1-t} &amp; \sqrt{t} \end{pmatrix}, \]</div>
<p>which simplifies to,</p>
<div class="arithmatex">\[ \mathbf{T}_\text{DC}(0.5) = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 &amp; i \\ i &amp; 1 \end{pmatrix}, \]</div>
<p>in the ideal case of <span class="arithmatex">\(t = 0.5\)</span> (i.e. 50:50). Each MZI may contribute an imbalanced
probability of photon loss in each of its arms. This is modelled by multiplying a
loss matrix,</p>
<div class="arithmatex">\[ \mathbf{T}_\text{loss}(\alpha_\text{up}, \alpha_\text{low}) = \begin{pmatrix}
\sqrt{1 - \alpha_\text{up}} &amp; 0 \\ 0 &amp; \sqrt{1 - \alpha_\text{low}} \end{pmatrix}, \]</div>
<p>where <span class="arithmatex">\(\alpha_\text{up}\)</span>, <span class="arithmatex">\(\alpha_\text{low}\)</span> are the fractions of light lost
in the upper and lower arms of the MZI, respectively. Altogether, the MZI transfer
matrix is given by,</p>
<div class="arithmatex">\[ \mathbf{T}_\text{MZI} = \mathbf{T}_\text{loss}(\alpha_\text{up}, \alpha_\text{low})\mathbf{T}_\text{DC}(t_2)\mathbf{T}_\text{PS}(2\theta)
\mathbf{T}_\text{DC}(t_1)\mathbf{T}_\text{PS}(\phi) = \begin{pmatrix} \sqrt{1 - \alpha_\text{up}} &amp; 0 \\ 0 &amp; \sqrt{1 - \alpha_\text{low}} \end{pmatrix}
\begin{pmatrix} \sqrt{t_2} &amp; i\sqrt{1-t_2} \\ i\sqrt{1-t_2} &amp; \sqrt{t_2} \end{pmatrix}\begin{pmatrix} e^{i2\theta} &amp; 0 \\ 0 &amp; 1 \end{pmatrix}
\begin{pmatrix} \sqrt{t_1} &amp; i\sqrt{1-t_1} \\ i\sqrt{1-t_1} &amp; \sqrt{t_1} \end{pmatrix}\begin{pmatrix} e^{i\phi} &amp; 0 \\ 0 &amp; 1 \end{pmatrix}, \]</div>
<p>which simplifies to,</p>
<div class="arithmatex">\[ \mathbf{T}_\text{MZI} = \mathbf{T}_\text{loss}(0, 0)\mathbf{T}_\text{DC}(0.5)\mathbf{T}_\text{PS}(2\theta)\mathbf{T}_\text{DC}(0.5)\mathbf{T}_\text{PS}(\phi) =
ie^{i\theta}\begin{pmatrix} e^{i\phi}\sin{\theta} &amp; \cos{\theta} \\ e^{i\phi}\cos{\theta} &amp; -\sin{\theta} \end{pmatrix}, \]</div>
<p>in the ideal case of <span class="arithmatex">\(t_1 = t_2 = 0.5\)</span>, <span class="arithmatex">\(\alpha_1 = \alpha_2 = 0\)</span>. This
function constructs the MZI transfer matrix from its parameters, and
optionally returns its inverse, <span class="arithmatex">\(\mathbf{T}_\text{MZI}^{-1}\)</span>, if
<code>inv = True</code> is set.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>phi</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Phase shift <span class="arithmatex">\(\phi\)</span></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>twotheta</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Phase shift <span class="arithmatex">\(2\theta\)</span></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>SR1</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Splitting ratio of the first directional coupler in the MZI, <span class="arithmatex">\(t_1\)</span></p></td>
          <td>
                <code>0.5</code>
          </td>
        </tr>
        <tr>
          <td><code>SR2</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Splitting ratio of the second directional coupler in the MZI, <span class="arithmatex">\(t_2\)</span></p></td>
          <td>
                <code>0.5</code>
          </td>
        </tr>
        <tr>
          <td><code>alpha_up</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Fraction of light lost in the upper arm of the MZI, <span class="arithmatex">\(\alpha_\text{up}\)</span></p></td>
          <td>
                <code>0</code>
          </td>
        </tr>
        <tr>
          <td><code>alpha_low</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Fraction of light lost in the lower arm of the MZI, <span class="arithmatex">\(\alpha_\text{low}\)</span></p></td>
          <td>
                <code>0</code>
          </td>
        </tr>
        <tr>
          <td><code>inv</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>Boolean that controls whether the MZI matrix or its inverse is returned</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A <span class="arithmatex">\(2\times 2\)</span> 2D array that represents the MZI transfer matrix</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>quotonic/clements.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">mzi</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">phi</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">twotheta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">SR1</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
    <span class="n">SR2</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
    <span class="n">alpha_up</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">alpha_low</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">inv</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct $2\\times 2$ MZI transfer matrix.</span>

<span class="sd">    Each MZI, as displayed below, consists of two phase shifters enacting respective</span>
<span class="sd">    phase shifts $\\phi$, $\\theta$, and two directional couplers with respective</span>
<span class="sd">    splitting ratios $t_1$, $t_2$ (ideally, $t_1 = t_2 = 0.5$).</span>

<span class="sd">    &lt;p align=&quot;center&quot;&gt;</span>
<span class="sd">    &lt;img width=&quot;500&quot; src=&quot;img/mzi.png&quot;&gt;</span>
<span class="sd">    &lt;/p&gt;</span>

<span class="sd">    The phase shifter transfer matrices are given by,</span>

<span class="sd">    $$ \\mathbf{T}_\\text{PS}(\\phi) = \\begin{pmatrix} e^{i\\phi} &amp; 0 \\\ 0 &amp; 1 \\end{pmatrix} \qquad\qquad</span>
<span class="sd">    \\mathbf{T}_\\text{PS}(2\\theta) = \\begin{pmatrix} e^{i2\\theta} &amp; 0 \\\ 0 &amp; 1 \\end{pmatrix}, $$</span>

<span class="sd">    for phase shifts $\\phi$ and $2\\theta$ respectively. The directional coupler</span>
<span class="sd">    transfer matrix is given by,</span>

<span class="sd">    $$ \\mathbf{T}_\\text{DC}(t) = \\begin{pmatrix} \\sqrt{t} &amp; i\\sqrt{1-t} \\\ i\\sqrt{1-t} &amp; \\sqrt{t} \\end{pmatrix}, $$</span>

<span class="sd">    which simplifies to,</span>

<span class="sd">    $$ \\mathbf{T}_\\text{DC}(0.5) = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 &amp; i \\\ i &amp; 1 \\end{pmatrix}, $$</span>

<span class="sd">    in the ideal case of $t = 0.5$ (i.e. 50:50). Each MZI may contribute an imbalanced</span>
<span class="sd">    probability of photon loss in each of its arms. This is modelled by multiplying a</span>
<span class="sd">    loss matrix,</span>

<span class="sd">    $$ \\mathbf{T}_\\text{loss}(\\alpha_\\text{up}, \\alpha_\\text{low}) = \\begin{pmatrix}</span>
<span class="sd">    \\sqrt{1 - \\alpha_\\text{up}} &amp; 0 \\\ 0 &amp; \\sqrt{1 - \\alpha_\\text{low}} \\end{pmatrix}, $$</span>

<span class="sd">    where $\\alpha_\\text{up}$, $\\alpha_\\text{low}$ are the fractions of light lost</span>
<span class="sd">    in the upper and lower arms of the MZI, respectively. Altogether, the MZI transfer</span>
<span class="sd">    matrix is given by,</span>

<span class="sd">    $$ \\mathbf{T}_\\text{MZI} = \\mathbf{T}_\\text{loss}(\\alpha_\\text{up}, \\alpha_\\text{low})\\mathbf{T}_\\text{DC}(t_2)\\mathbf{T}_\\text{PS}(2\\theta)</span>
<span class="sd">    \\mathbf{T}_\\text{DC}(t_1)\\mathbf{T}_\\text{PS}(\\phi) = \\begin{pmatrix} \\sqrt{1 - \\alpha_\\text{up}} &amp; 0 \\\ 0 &amp; \\sqrt{1 - \\alpha_\\text{low}} \\end{pmatrix}</span>
<span class="sd">    \\begin{pmatrix} \\sqrt{t_2} &amp; i\\sqrt{1-t_2} \\\ i\\sqrt{1-t_2} &amp; \\sqrt{t_2} \\end{pmatrix}\\begin{pmatrix} e^{i2\\theta} &amp; 0 \\\ 0 &amp; 1 \\end{pmatrix}</span>
<span class="sd">    \\begin{pmatrix} \\sqrt{t_1} &amp; i\\sqrt{1-t_1} \\\ i\\sqrt{1-t_1} &amp; \\sqrt{t_1} \\end{pmatrix}\\begin{pmatrix} e^{i\\phi} &amp; 0 \\\ 0 &amp; 1 \\end{pmatrix}, $$</span>

<span class="sd">    which simplifies to,</span>

<span class="sd">    $$ \\mathbf{T}_\\text{MZI} = \\mathbf{T}_\\text{loss}(0, 0)\\mathbf{T}_\\text{DC}(0.5)\\mathbf{T}_\\text{PS}(2\\theta)\\mathbf{T}_\\text{DC}(0.5)\\mathbf{T}_\\text{PS}(\\phi) =</span>
<span class="sd">    ie^{i\\theta}\\begin{pmatrix} e^{i\\phi}\\sin{\\theta} &amp; \\cos{\\theta} \\\ e^{i\\phi}\\cos{\\theta} &amp; -\\sin{\\theta} \\end{pmatrix}, $$</span>

<span class="sd">    in the ideal case of $t_1 = t_2 = 0.5$, $\\alpha_1 = \\alpha_2 = 0$. This</span>
<span class="sd">    function constructs the MZI transfer matrix from its parameters, and</span>
<span class="sd">    optionally returns its inverse, $\\mathbf{T}_\\text{MZI}^{-1}$, if</span>
<span class="sd">    `inv = True` is set.</span>

<span class="sd">    Args:</span>
<span class="sd">        phi: Phase shift $\\phi$</span>
<span class="sd">        twotheta: Phase shift $2\\theta$</span>
<span class="sd">        SR1: Splitting ratio of the first directional coupler in the MZI, $t_1$</span>
<span class="sd">        SR2: Splitting ratio of the second directional coupler in the MZI, $t_2$</span>
<span class="sd">        alpha_up: Fraction of light lost in the upper arm of the MZI, $\\alpha_\\text{up}$</span>
<span class="sd">        alpha_low: Fraction of light lost in the lower arm of the MZI, $\\alpha_\\text{low}$</span>
<span class="sd">        inv: Boolean that controls whether the MZI matrix or its inverse is returned</span>

<span class="sd">    Returns:</span>
<span class="sd">        A $2\\times 2$ 2D array that represents the MZI transfer matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Construct phase shifter transfer matrices</span>
    <span class="n">ps_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span><span class="p">),</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">))</span>
    <span class="n">ps_twotheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">twotheta</span><span class="p">),</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">))</span>

    <span class="c1"># Construct directional coupler transfer matrices</span>
    <span class="n">dc_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">SR1</span><span class="p">),</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">SR1</span><span class="p">)],</span> <span class="p">[</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">SR1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">SR1</span><span class="p">)]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">dc_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">SR2</span><span class="p">),</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">SR2</span><span class="p">)],</span> <span class="p">[</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">SR2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">SR2</span><span class="p">)]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="c1"># Construct loss transfer matrix</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">alpha_up</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">alpha_low</span><span class="p">)]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="c1"># Calculate full MZI transfer matrix</span>
    <span class="n">mzi</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">loss</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dc_2</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ps_twotheta</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dc_1</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ps_phi</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">inv</span><span class="p">:</span>
        <span class="n">mzi_inv</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">mzi</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">mzi_inv</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mzi</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="quotonic.clements.Mesh.mzi_column" class="doc doc-heading">
<code class="highlight language-python"><span class="n">mzi_column</span><span class="p">(</span><span class="n">placementSpecifier</span><span class="p">,</span> <span class="n">phis</span><span class="p">,</span> <span class="n">twothetas</span><span class="p">,</span> <span class="n">SRs</span><span class="p">,</span> <span class="n">alphas</span><span class="p">)</span></code>

<a href="#quotonic.clements.Mesh.mzi_column" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Construct MZI transfer matrix for a column of the Clements mesh.</p>
<p>The Clements mesh (see <code>encode</code> for an example diagram) can be separated into
columns of MZIs. Each MZI in a given column contributes a transformation,
<span class="arithmatex">\(\mathbf{T}_{p,q}\)</span>, that is both block diagonal and <span class="arithmatex">\(m\times m\)</span>. Starting
from the <span class="arithmatex">\(m\times m\)</span> identity matrix, a <span class="arithmatex">\(2\times 2\)</span> MZI transfer matrix is
inserted into the block from element <span class="arithmatex">\((p,p)\)</span> to element <span class="arithmatex">\((q,q)\)</span>. All the
separate transformations in a given column commute which each other since they
act on separate blocks. Thus, this function constructs all of the
<span class="arithmatex">\(\mathbf{T}_{p,q}\)</span> transformations in a given column as a single <span class="arithmatex">\(m\times m\)</span>
matrix that is returned.</p>
<p>The location of the first MZI transfer matrix insertion is controlled by
<code>placementSpecifier</code>, then a <span class="arithmatex">\(2\times 2\)</span> <span class="arithmatex">\(\mathbf{T}_\text{MZI}\)</span> can be
inserted at each separated block along the diagonal. For example, consider
<span class="arithmatex">\(m = 5\)</span>, <code>placementSpecifier = 0</code>, and the ideal case with no imperfections.
The output matrix will then incorporate the MZIs acting on the pair of modes
<span class="arithmatex">\((0,1)\)</span> and <span class="arithmatex">\((2,3)\)</span>. As the function proceeds, the matrix changes as,</p>
<div class="arithmatex">\[ \begin{pmatrix} 1&amp;0&amp;0&amp;0&amp;0 \\ 0&amp;1&amp;0&amp;0&amp;0 \\ 0&amp;0&amp;1&amp;0&amp;0 \\ 0&amp;0&amp;0&amp;1&amp;0 \\ 0&amp;0&amp;0&amp;0&amp;1 \end{pmatrix} \longrightarrow
\begin{pmatrix} ie^{i\theta_{0,1}}e^{i\phi_{0,1}}\sin{\theta_{0,1}} &amp; ie^{i\theta_{0,1}}\cos{\theta_{0,1}}&amp;0&amp;0&amp;0 \\ ie^{i\theta_{0,1}}e^{i\phi_{0,1}}\cos{\theta_{0,1}} &amp; ie^{i\theta_{0,1}}\sin{\theta_{0,1}}&amp;0&amp;0&amp;0
\\ 0&amp;0&amp;1&amp;0&amp;0 \\ 0&amp;0&amp;0&amp;1&amp;0 \\ 0&amp;0&amp;0&amp;0&amp;1 \end{pmatrix} \longrightarrow \begin{pmatrix} ie^{i\theta_{0,1}}e^{i\phi_{0,1}}\sin{\theta_{0,1}} &amp; ie^{i\theta_{0,1}}\cos{\theta_{0,1}}&amp;0&amp;0&amp;0
\\ ie^{i\theta_{0,1}}e^{i\phi_{0,1}}\cos{\theta_{0,1}} &amp; ie^{i\theta_{0,1}}\sin{\theta_{0,1}}&amp;0&amp;0&amp;0 \\ 0&amp;0&amp;ie^{i\theta_{2,3}}e^{i\phi_{2,3}}\sin{\theta_{2,3}} &amp; ie^{i\theta_{2,3}}\cos{\theta_{2,3}}&amp;0
\\ 0&amp;0&amp;ie^{i\theta_{2,3}}e^{i\phi_{2,3}}\cos{\theta_{2,3}} &amp; ie^{i\theta_{2,3}}\sin{\theta_{2,3}}&amp;0 \\ 0&amp;0&amp;0&amp;0&amp;1 \end{pmatrix}. \]</div>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>placementSpecifier</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>A placeholder that instructs the function where to begin inserting MZI transfer matrices</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>phis</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A 1D array of length <code>(m - placementSpecifier) // 2</code> that includes the <span class="arithmatex">\(\phi\)</span> phase shifts for each MZI in the column</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>twothetas</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A 1D array of length <code>(m - placementSpecifier) // 2</code> that includes the <span class="arithmatex">\(2\theta\)</span> phase shifts for each MZI in the column</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>SRs</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A 1D array of length <code>2 * (m - placementSpecifier // 2)</code> that includes the directional coupler splitting ratios, <span class="arithmatex">\(t\)</span>, for each MZI in the column</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>alphas</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A 1D array of length <code>m</code> that includes the fractions of light lost, <span class="arithmatex">\(\alpha\)</span>, for each optical mode in the column</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An <span class="arithmatex">\(m\times m\)</span> 2D array that represents the transformation yielded by a column of MZIs</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>quotonic/clements.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">mzi_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">placementSpecifier</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">phis</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">twothetas</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">SRs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">alphas</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct MZI transfer matrix for a column of the Clements mesh.</span>

<span class="sd">    The Clements mesh (see `encode` for an example diagram) can be separated into</span>
<span class="sd">    columns of MZIs. Each MZI in a given column contributes a transformation,</span>
<span class="sd">    $\\mathbf{T}_{p,q}$, that is both block diagonal and $m\\times m$. Starting</span>
<span class="sd">    from the $m\\times m$ identity matrix, a $2\\times 2$ MZI transfer matrix is</span>
<span class="sd">    inserted into the block from element $(p,p)$ to element $(q,q)$. All the</span>
<span class="sd">    separate transformations in a given column commute which each other since they</span>
<span class="sd">    act on separate blocks. Thus, this function constructs all of the</span>
<span class="sd">    $\\mathbf{T}_{p,q}$ transformations in a given column as a single $m\\times m$</span>
<span class="sd">    matrix that is returned.</span>

<span class="sd">    The location of the first MZI transfer matrix insertion is controlled by</span>
<span class="sd">    `placementSpecifier`, then a $2\\times 2$ $\\mathbf{T}_\\text{MZI}$ can be</span>
<span class="sd">    inserted at each separated block along the diagonal. For example, consider</span>
<span class="sd">    $m = 5$, `placementSpecifier = 0`, and the ideal case with no imperfections.</span>
<span class="sd">    The output matrix will then incorporate the MZIs acting on the pair of modes</span>
<span class="sd">    $(0,1)$ and $(2,3)$. As the function proceeds, the matrix changes as,</span>

<span class="sd">    $$ \\begin{pmatrix} 1&amp;0&amp;0&amp;0&amp;0 \\\ 0&amp;1&amp;0&amp;0&amp;0 \\\ 0&amp;0&amp;1&amp;0&amp;0 \\\ 0&amp;0&amp;0&amp;1&amp;0 \\\ 0&amp;0&amp;0&amp;0&amp;1 \\end{pmatrix} \\longrightarrow</span>
<span class="sd">    \\begin{pmatrix} ie^{i\\theta_{0,1}}e^{i\\phi_{0,1}}\\sin{\\theta_{0,1}} &amp; ie^{i\\theta_{0,1}}\\cos{\\theta_{0,1}}&amp;0&amp;0&amp;0 \\\ ie^{i\\theta_{0,1}}e^{i\\phi_{0,1}}\\cos{\\theta_{0,1}} &amp; ie^{i\\theta_{0,1}}\\sin{\\theta_{0,1}}&amp;0&amp;0&amp;0</span>
<span class="sd">    \\\ 0&amp;0&amp;1&amp;0&amp;0 \\\ 0&amp;0&amp;0&amp;1&amp;0 \\\ 0&amp;0&amp;0&amp;0&amp;1 \\end{pmatrix} \\longrightarrow \\begin{pmatrix} ie^{i\\theta_{0,1}}e^{i\\phi_{0,1}}\\sin{\\theta_{0,1}} &amp; ie^{i\\theta_{0,1}}\\cos{\\theta_{0,1}}&amp;0&amp;0&amp;0</span>
<span class="sd">    \\\ ie^{i\\theta_{0,1}}e^{i\\phi_{0,1}}\\cos{\\theta_{0,1}} &amp; ie^{i\\theta_{0,1}}\\sin{\\theta_{0,1}}&amp;0&amp;0&amp;0 \\\ 0&amp;0&amp;ie^{i\\theta_{2,3}}e^{i\\phi_{2,3}}\\sin{\\theta_{2,3}} &amp; ie^{i\\theta_{2,3}}\\cos{\\theta_{2,3}}&amp;0</span>
<span class="sd">    \\\ 0&amp;0&amp;ie^{i\\theta_{2,3}}e^{i\\phi_{2,3}}\\cos{\\theta_{2,3}} &amp; ie^{i\\theta_{2,3}}\\sin{\\theta_{2,3}}&amp;0 \\\ 0&amp;0&amp;0&amp;0&amp;1 \\end{pmatrix}. $$</span>

<span class="sd">    Args:</span>
<span class="sd">        placementSpecifier: A placeholder that instructs the function where to begin inserting MZI transfer matrices</span>
<span class="sd">        phis: A 1D array of length `(m - placementSpecifier) // 2` that includes the $\\phi$ phase shifts for each MZI in the column</span>
<span class="sd">        twothetas: A 1D array of length `(m - placementSpecifier) // 2` that includes the $2\\theta$ phase shifts for each MZI in the column</span>
<span class="sd">        SRs: A 1D array of length `2 * (m - placementSpecifier // 2)` that includes the directional coupler splitting ratios, $t$, for each MZI in the column</span>
<span class="sd">        alphas: A 1D array of length `m` that includes the fractions of light lost, $\\alpha$, for each optical mode in the column</span>

<span class="sd">    Returns:</span>
<span class="sd">        An $m\\times m$ 2D array that represents the transformation yielded by a column of MZIs</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Place the MZI transfer matrices $T_{p,q}$ as blocks along the diagonal from (p,p) to (q,q)</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">mzi_column</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numModes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">placementSpecifier</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
        <span class="n">mzi_column</span><span class="p">[</span><span class="n">p</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">p</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mzi</span><span class="p">(</span><span class="n">phis</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">twothetas</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">SR1</span><span class="o">=</span><span class="n">SRs</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">SR2</span><span class="o">=</span><span class="n">SRs</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="mi">2</span>

    <span class="c1"># Multiply the losses for each optical mode in the column</span>
    <span class="n">mzi_column</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">alphas</span><span class="p">)),</span> <span class="n">mzi_column</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mzi_column</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="quotonic.clements.Mesh.set_SR" class="doc doc-heading">
<code class="highlight language-python"><span class="n">set_SR</span><span class="p">(</span><span class="n">SR</span><span class="p">)</span></code>

<a href="#quotonic.clements.Mesh.set_SR" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Set all splitting ratios in the directional couplers of the Clements mesh.</p>
<p>Each MZI in a Clements mesh features two directional couplers, each nominally with
a 50:50 splitting ratio, however, this may vary in imperfect cases. Here, the
splitting ratios, <span class="arithmatex">\(t\)</span>, for the <span class="arithmatex">\(m(m-1)\)</span> directional couplers can be manually
specified in the order at which they appear during the encoding scheme. See <code>__init__</code>
and <code>encode</code> for more details.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>SR</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A 1D array of length <span class="arithmatex">\(m(m-1)\)</span> including the splitting ratios, <span class="arithmatex">\(t\)</span>, for each directional coupler in the Clements mesh</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>quotonic/clements.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">set_SR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SR</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set all splitting ratios in the directional couplers of the Clements mesh.</span>

<span class="sd">    Each MZI in a Clements mesh features two directional couplers, each nominally with</span>
<span class="sd">    a 50:50 splitting ratio, however, this may vary in imperfect cases. Here, the</span>
<span class="sd">    splitting ratios, $t$, for the $m(m-1)$ directional couplers can be manually</span>
<span class="sd">    specified in the order at which they appear during the encoding scheme. See `__init__`</span>
<span class="sd">    and `encode` for more details.</span>

<span class="sd">    Args:</span>
<span class="sd">        SR: A 1D array of length $m(m-1)$ including the splitting ratios, $t$, for each directional coupler in the Clements mesh</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">SR</span> <span class="o">=</span> <span class="n">SR</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="quotonic.clements.Mesh.set_alpha" class="doc doc-heading">
<code class="highlight language-python"><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span></code>

<a href="#quotonic.clements.Mesh.set_alpha" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Set all component losses in the Clements mesh.</p>
<p>A Clements mesh with <span class="arithmatex">\(m\)</span> optical modes features <span class="arithmatex">\(\frac{1}{2}m(m-1)\)</span> MZIs, <span class="arithmatex">\(m\)</span> flat
sections in parallel with MZIs, and <span class="arithmatex">\(m\)</span> output phase shifters, each contributing a
specific fraction of light lost when photons propagate through them. The MZIs may
have imbalanced losses in each arm, and thus there are two values for the fraction
of light lost per MZI. Here, all of the fractions can be specified manually, in the
order in which each component appears during the encoding scheme. See <code>__init__</code> and
<code>encode</code> for more details.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>alpha</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A 1D array of length <span class="arithmatex">\(m(m+1)\)</span> including the fractions of light lost, <span class="arithmatex">\(\alpha\)</span>, for each component in the Clements mesh</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>quotonic/clements.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">set_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set all component losses in the Clements mesh.</span>

<span class="sd">    A Clements mesh with $m$ optical modes features $\\frac{1}{2}m(m-1)$ MZIs, $m$ flat</span>
<span class="sd">    sections in parallel with MZIs, and $m$ output phase shifters, each contributing a</span>
<span class="sd">    specific fraction of light lost when photons propagate through them. The MZIs may</span>
<span class="sd">    have imbalanced losses in each arm, and thus there are two values for the fraction</span>
<span class="sd">    of light lost per MZI. Here, all of the fractions can be specified manually, in the</span>
<span class="sd">    order in which each component appears during the encoding scheme. See `__init__` and</span>
<span class="sd">    `encode` for more details.</span>

<span class="sd">    Args:</span>
<span class="sd">        alpha: A 1D array of length $m(m+1)$ including the fractions of light lost, $\\alpha$, for each component in the Clements mesh</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="quotonic.clements.Mesh.set_phases" class="doc doc-heading">
<code class="highlight language-python"><span class="n">set_phases</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span></code>

<a href="#quotonic.clements.Mesh.set_phases" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Set all phase shifts in the Clements mesh.</p>
<p>A Clements mesh with <span class="arithmatex">\(m\)</span> optical modes features <span class="arithmatex">\(m^2\)</span> phase shifts. The phase shifts
input here must be ordered in accordance with the encoding scheme. See <code>encode</code> for
more details.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>phases</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A 1D array of length <span class="arithmatex">\(m^2\)</span> including MZI and output phase shifts for the Clements mesh</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>quotonic/clements.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">set_phases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phases</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set all phase shifts in the Clements mesh.</span>

<span class="sd">    A Clements mesh with $m$ optical modes features $m^2$ phase shifts. The phase shifts</span>
<span class="sd">    input here must be ordered in accordance with the encoding scheme. See `encode` for</span>
<span class="sd">    more details.</span>

<span class="sd">    Args:</span>
<span class="sd">        phases: A 1D array of length $m^2$ including MZI and output phase shifts for the Clements mesh</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">phases</span> <span class="o">=</span> <span class="n">phases</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>



  </div>

  </div>

</div>




  </div>

  </div>

</div>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Maintained by <a href="https://www.linkedin.com/in/jacobewaniuk/">Jacob Ewaniuk</a>.
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        <div class="md-social">
  
    
    
    
    
      
      
    
    <a href="https://github.com/QNLQueens/quotonic" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://pypi.com/project/quotonic" target="_blank" rel="noopener" title="pypi.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.8 200.5c-7.7-30.9-22.3-54.2-53.4-54.2h-40.1v47.4c0 36.8-31.2 67.8-66.8 67.8H172.7c-29.2 0-53.4 25-53.4 54.3v101.8c0 29 25.2 46 53.4 54.3 33.8 9.9 66.3 11.7 106.8 0 26.9-7.8 53.4-23.5 53.4-54.3v-40.7H226.2v-13.6h160.2c31.1 0 42.6-21.7 53.4-54.2 11.2-33.5 10.7-65.7 0-108.6zM286.2 404c11.1 0 20.1 9.1 20.1 20.3 0 11.3-9 20.4-20.1 20.4-11 0-20.1-9.2-20.1-20.4.1-11.3 9.1-20.3 20.1-20.3zM167.8 248.1h106.8c29.7 0 53.4-24.5 53.4-54.3V91.9c0-29-24.4-50.7-53.4-55.6-35.8-5.9-74.7-5.6-106.8.1-45.2 8-53.4 24.7-53.4 55.6v40.7h106.9v13.6h-147c-31.1 0-58.3 18.7-66.8 54.2-9.8 40.7-10.2 66.1 0 108.6 7.6 31.6 25.7 54.2 56.8 54.2H101v-48.8c0-35.3 30.5-66.4 66.8-66.4zm-6.7-142.6c-11.1 0-20.1-9.1-20.1-20.3.1-11.3 9-20.4 20.1-20.4 11 0 20.1 9.2 20.1 20.4s-9 20.3-20.1 20.3z"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": ".", "features": [], "search": "assets/javascripts/workers/search.208ed371.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="assets/javascripts/bundle.2a6f1dda.min.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>