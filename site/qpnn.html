
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="A platform for performing efficient simulations in the quantum photonic domain.">
      
      
        <meta name="author" content="Jacob Ewaniuk">
      
      
      
        <link rel="prev" href="kerr.html">
      
      
        <link rel="next" href="training_sets.html">
      
      <link rel="icon" href="assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-9.0.13">
    
    
      
        <title>QPNN - quotonic</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/main.ffa9267a.min.css">
      
        
        <link rel="stylesheet" href="assets/stylesheets/palette.a0c5b2b5.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL(".",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="deep-orange">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#quotonic.qpnn" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="index.html" title="quotonic" class="md-header__button md-logo" aria-label="quotonic" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            quotonic
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              QPNN
            
          </span>
        </div>
      </div>
    </div>
    
      <form class="md-header__option" data-md-component="palette">
        
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="deep-orange"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
          
            <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
            </label>
          
        
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="deep-orange"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
          
            <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
            </label>
          
        
      </form>
    
    
    
    
      <div class="md-header__source">
        <a href="https://github.com/QNLQueens/quotonic" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    QNLQueens/quotonic
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="index.html" title="quotonic" class="md-nav__button md-logo" aria-label="quotonic" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    quotonic
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/QNLQueens/quotonic" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    QNLQueens/quotonic
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="index.html" class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="fock.html" class="md-nav__link">
        Fock
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="clements.html" class="md-nav__link">
        Clements
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="aa.html" class="md-nav__link">
        AA
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="kerr.html" class="md-nav__link">
        Kerr
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          QPNN
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="qpnn.html" class="md-nav__link md-nav__link--active">
        QPNN
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#quotonic.qpnn" class="md-nav__link">
    quotonic.qpnn
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#quotonic.qpnn.QPNN" class="md-nav__link">
    QPNN
  </a>
  
    <nav class="md-nav" aria-label="QPNN">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.QPNN.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.QPNN.calculate_Fcon" class="md-nav__link">
    calculate_Fcon()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.QPNN.calculate_Func" class="md-nav__link">
    calculate_Func()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.QPNN.calculate_Pcb" class="md-nav__link">
    calculate_Pcb()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.QPNN.set_SRs" class="md-nav__link">
    set_SRs()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.QPNN.set_alphas" class="md-nav__link">
    set_alphas()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.QPNN.set_phases" class="md-nav__link">
    set_phases()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.QPNN.sysFunc" class="md-nav__link">
    sysFunc()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="training_sets.html" class="md-nav__link">
        Training Sets
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="misc.html" class="md-nav__link">
        Miscellaneous
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#quotonic.qpnn" class="md-nav__link">
    quotonic.qpnn
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#quotonic.qpnn.QPNN" class="md-nav__link">
    QPNN
  </a>
  
    <nav class="md-nav" aria-label="QPNN">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.QPNN.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.QPNN.calculate_Fcon" class="md-nav__link">
    calculate_Fcon()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.QPNN.calculate_Func" class="md-nav__link">
    calculate_Func()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.QPNN.calculate_Pcb" class="md-nav__link">
    calculate_Pcb()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.QPNN.set_SRs" class="md-nav__link">
    set_SRs()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.QPNN.set_alphas" class="md-nav__link">
    set_alphas()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.QPNN.set_phases" class="md-nav__link">
    set_phases()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.QPNN.sysFunc" class="md-nav__link">
    sysFunc()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


  <h1>QPNN</h1>

<div class="doc doc-object doc-module">


<a id="quotonic.qpnn"></a>
  <div class="doc doc-contents first">
  
      <p>The <code>quotonic.qpnn</code> module includes a class that allows quantum photonic neural networks
(QPNNs) to be instantiated. When instantiating a QPNN, the user can specify whether it
should include photon propagation losses (balanced or unbalanced) and/or imperfect
directional coupler splitting ratios. The user may also specify the strength of the
network's single-site Kerr nonlinearities, and/or which ones are on/off.</p>
<p>The user's specifications are passed through to other classes/functions when constructing
the network model. A QPNN is designed to operate on a certain number of photons, <span class="arithmatex">\(n\)</span>, with
a certain number of optical modes <span class="arithmatex">\(m\)</span>. It also features <span class="arithmatex">\(L\)</span> layers where each is a mesh of
Mach-Zehnder interferometers (MZIs) arranged in the Clements configuration (see
<a href="clements.html">Clements</a>). Single-site Kerr nonlinearities are wedged between layers
(see <a href="kerr.html">Kerr</a>). Altogether, the system function is representative of a nonlinear
optical transformation on quantum photonic states that is parameterized by the phase shifts
in each MZI throughout the entire network.</p>
<p>Some code in this module is adapted from <a href="https://github.com/steinbrecher/bosonic">Bosonic: A Quantum Optics Library</a>,
as originally designed for use in <a href="https://doi.org/10.1038/s41534-019-0174-7">G. R. Steinbrecher <em>et al</em>., “Quantum optical neural networks”,
<em>npj Quantum Inf</em> <strong>5</strong>, 60 (2019)</a>. In this article,
and in <a href="https://doi.org/10.1002/qute.202200125">J. Ewaniuk <em>et al</em>., "Imperfect Quantum Photonic Neural Networks", <em>Adv Quantum
Technol.</em> 2200125 (2023)</a>, QPNNs are more
thoroughly described.</p>

  

  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="quotonic.qpnn.QPNN" class="doc doc-heading">
        <code>QPNN</code>


<a href="#quotonic.qpnn.QPNN" class="headerlink" title="Permanent link">&para;</a></h2>


  <div class="doc doc-contents ">

  
      <p>Model of a quantum photonic neural network (QPNN).</p>
<p>Each QPNN is designed to operate on a certain number of photons, <span class="arithmatex">\(n\)</span> with a certain
number of optical modes <span class="arithmatex">\(m\)</span>, and features <span class="arithmatex">\(L\)</span> layers. The user may also specify the
imperfections experienced by a given <code>QPNN</code> instance. The options include photon
propagation losses (balanced or unbalanced), imbalanced directional coupler
splitting ratios, weak optical nonlinearities, or even <em>burnt out</em> nonlinearities.</p>
<p>This class allows QPNNs to be instantiated with provided characteristics. Then, the
system transfer function of the network may be evaluated based on the provided or
default attributes.</p>

  <p><strong>Attributes:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>numPhotons</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Number of photons, <span class="arithmatex">\(n\)</span></p></td>
        </tr>
        <tr>
          <td><code>numModes</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Number of optical modes, <span class="arithmatex">\(m\)</span></p></td>
        </tr>
        <tr>
          <td><code>numLayers</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Number of layers, <span class="arithmatex">\(L\)</span></p></td>
        </tr>
        <tr>
          <td><code>varphi</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Effective nonlinear phase shift, <span class="arithmatex">\(\varphi\)</span></p></td>
        </tr>
        <tr>
          <td><code>burnoutMap</code></td>
          <td>
                <code><span title="typing.Optional">Optional</span>[<span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span>]</code>
          </td>
          <td><p>A 1D array of length <span class="arithmatex">\(m\)</span>, with either boolean or binary elements, specifying whether nonlinearities are on/off for specific modes</p></td>
        </tr>
        <tr>
          <td><code>alphaWG</code></td>
          <td>
                <code><span title="typing.Optional">Optional</span>[float]</code>
          </td>
          <td><p>Mean propagation losses, <span class="arithmatex">\(\alpha_\mathrm{WG}\)</span>, in <span class="arithmatex">\(\text{dB}/\text{cm}\)</span></p></td>
        </tr>
        <tr>
          <td><code>std_alphaWG</code></td>
          <td>
                <code><span title="typing.Optional">Optional</span>[float]</code>
          </td>
          <td><p>Standard deviation of the propagation losses, <span class="arithmatex">\(\alpha_\mathrm{WG}\)</span>, in <span class="arithmatex">\(\text{dB}/\text{cm}\)</span></p></td>
        </tr>
        <tr>
          <td><code>std_SR</code></td>
          <td>
                <code><span title="typing.Optional">Optional</span>[float]</code>
          </td>
          <td><p>Standard deviation of the directional coupler splitting ratio, <span class="arithmatex">\(t\)</span></p></td>
        </tr>
        <tr>
          <td><code>ellMZI</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Characteristic length of a MZI, <span class="arithmatex">\(\ell_\mathrm{MZI}\)</span>, in <span class="arithmatex">\(\text{cm}\)</span></p></td>
        </tr>
        <tr>
          <td><code>ellPS</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Characteristic length of a phase shifter, <span class="arithmatex">\(\ell_\mathrm{PS}\)</span>, in <span class="arithmatex">\(\text{cm}\)</span></p></td>
        </tr>
        <tr>
          <td><code>ellF</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Characteristic length of a flat section in parallel with a MZI, <span class="arithmatex">\(\ell_\mathrm{F}\)</span>, in <span class="arithmatex">\(\text{cm}\)</span></p></td>
        </tr>
        <tr>
          <td><code>alphas</code></td>
          <td>
                <code>list[<span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span>]</code>
          </td>
          <td><p>List of 1D arrays of the fractions of light lost in each component throughout the network, separated by layer</p></td>
        </tr>
        <tr>
          <td><code>SRs</code></td>
          <td>
                <code>list[<span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span>]</code>
          </td>
          <td><p>List of 1D arrays of the directional coupler splitting ratios throughout the network, separated by layer</p></td>
        </tr>
        <tr>
          <td><code>fockDim</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Dimension of the Fock basis, <span class="arithmatex">\(N\)</span></p></td>
        </tr>
        <tr>
          <td><code>pspl</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Number of phase shift parameters per QPNN layer, <span class="arithmatex">\(m^2\)</span></p></td>
        </tr>
        <tr>
          <td><code>allPhases</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A 1D array of length <span class="arithmatex">\(m^2L\)</span> storing all the phase shift parameters for the network</p></td>
        </tr>
        <tr>
          <td><code>mesh</code></td>
          <td>
                <code>list</code>
          </td>
          <td><p>A list of all the Clements MZI meshes in the QPNN, one mesh per layer</p></td>
        </tr>
        <tr>
          <td><code>kerrU</code></td>
          <td>
                <code>list</code>
          </td>
          <td><p>A list of all the single-site Kerr nonlinearity sections in the QPNN, one between each pair of layers</p></td>
        </tr>
        <tr>
          <td><code>S</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>QPNN system transfer function, <span class="arithmatex">\(\mathbf{S}\)</span></p></td>
        </tr>
        <tr>
          <td><code>K</code></td>
          <td>
                <code><span title="typing.Optional">Optional</span>[int]</code>
          </td>
          <td><p>The number of input-output state pairs in the QPNN training set</p></td>
        </tr>
        <tr>
          <td><code>psiIn</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An <span class="arithmatex">\(N\times K\)</span> 2D array containing the <span class="arithmatex">\(K\)</span> input states of the QPNN training set, resolved in the <span class="arithmatex">\(N\)</span>-dimensional Fock basis</p></td>
        </tr>
        <tr>
          <td><code>psiOut</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An <span class="arithmatex">\(N\times K\)</span> 2D array containing the <span class="arithmatex">\(K\)</span> output states of the QPNN training set, resolved in the <span class="arithmatex">\(N\)</span>-dimensional Fock basis</p></td>
        </tr>
        <tr>
          <td><code>Func</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>The unconditional fidelity, <span class="arithmatex">\(\mathcal{F}^\mathrm{(unc)}\)</span>, of the QPNN</p></td>
        </tr>
        <tr>
          <td><code>Fcon</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>The conditional fidelity, <span class="arithmatex">\(\mathcal{F}^\mathrm{(con)}\)</span>, of the QPNN</p></td>
        </tr>
        <tr>
          <td><code>Pcb</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>The computational basis probability, <span class="arithmatex">\(\mathcal{P}^\mathrm{(cb)}\)</span>, of the QPNN</p></td>
        </tr>
        <tr>
          <td><code>compBasisInds</code></td>
          <td>
                <code>list</code>
          </td>
          <td><p>List of the indices of states in the Fock basis that correspond to the computational basis</p></td>
        </tr>
        <tr>
          <td><code>compBasisDim</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Dimension of the computational basis</p></td>
        </tr>
    </tbody>
  </table>


        <details class="quote">
          <summary>Source code in <code>quotonic/qpnn.py</code></summary>
          <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">QPNN</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Model of a quantum photonic neural network (QPNN).</span>

<span class="sd">    Each QPNN is designed to operate on a certain number of photons, $n$ with a certain</span>
<span class="sd">    number of optical modes $m$, and features $L$ layers. The user may also specify the</span>
<span class="sd">    imperfections experienced by a given `QPNN` instance. The options include photon</span>
<span class="sd">    propagation losses (balanced or unbalanced), imbalanced directional coupler</span>
<span class="sd">    splitting ratios, weak optical nonlinearities, or even *burnt out* nonlinearities.</span>

<span class="sd">    This class allows QPNNs to be instantiated with provided characteristics. Then, the</span>
<span class="sd">    system transfer function of the network may be evaluated based on the provided or</span>
<span class="sd">    default attributes.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        numPhotons (int): Number of photons, $n$</span>
<span class="sd">        numModes (int): Number of optical modes, $m$</span>
<span class="sd">        numLayers (int): Number of layers, $L$</span>
<span class="sd">        varphi (float): Effective nonlinear phase shift, $\\varphi$</span>
<span class="sd">        burnoutMap (Optional[np.ndarray]): A 1D array of length $m$, with either boolean or binary elements, specifying whether nonlinearities are on/off for specific modes</span>
<span class="sd">        alphaWG (Optional[float]): Mean propagation losses, $\\alpha_\\mathrm{WG}$, in $\\text{dB}/\\text{cm}$</span>
<span class="sd">        std_alphaWG (Optional[float]): Standard deviation of the propagation losses, $\\alpha_\\mathrm{WG}$, in $\\text{dB}/\\text{cm}$</span>
<span class="sd">        std_SR (Optional[float]): Standard deviation of the directional coupler splitting ratio, $t$</span>
<span class="sd">        ellMZI (float): Characteristic length of a MZI, $\\ell_\\mathrm{MZI}$, in $\\text{cm}$</span>
<span class="sd">        ellPS (float): Characteristic length of a phase shifter, $\\ell_\\mathrm{PS}$, in $\\text{cm}$</span>
<span class="sd">        ellF (float): Characteristic length of a flat section in parallel with a MZI, $\\ell_\\mathrm{F}$, in $\\text{cm}$</span>
<span class="sd">        alphas (list[np.ndarray]): List of 1D arrays of the fractions of light lost in each component throughout the network, separated by layer</span>
<span class="sd">        SRs (list[np.ndarray]): List of 1D arrays of the directional coupler splitting ratios throughout the network, separated by layer</span>
<span class="sd">        fockDim (int): Dimension of the Fock basis, $N$</span>
<span class="sd">        pspl (int): Number of phase shift parameters per QPNN layer, $m^2$</span>
<span class="sd">        allPhases (np.ndarray): A 1D array of length $m^2L$ storing all the phase shift parameters for the network</span>
<span class="sd">        mesh (list): A list of all the Clements MZI meshes in the QPNN, one mesh per layer</span>
<span class="sd">        kerrU (list): A list of all the single-site Kerr nonlinearity sections in the QPNN, one between each pair of layers</span>
<span class="sd">        S (np.ndarray): QPNN system transfer function, $\\mathbf{S}$</span>
<span class="sd">        K (Optional[int]): The number of input-output state pairs in the QPNN training set</span>
<span class="sd">        psiIn (np.ndarray): An $N\\times K$ 2D array containing the $K$ input states of the QPNN training set, resolved in the $N$-dimensional Fock basis</span>
<span class="sd">        psiOut (np.ndarray): An $N\\times K$ 2D array containing the $K$ output states of the QPNN training set, resolved in the $N$-dimensional Fock basis</span>
<span class="sd">        Func (float): The unconditional fidelity, $\\mathcal{F}^\\mathrm{(unc)}$, of the QPNN</span>
<span class="sd">        Fcon (float): The conditional fidelity, $\\mathcal{F}^\\mathrm{(con)}$, of the QPNN</span>
<span class="sd">        Pcb (float): The computational basis probability, $\\mathcal{P}^\\mathrm{(cb)}$, of the QPNN</span>
<span class="sd">        compBasisInds (list): List of the indices of states in the Fock basis that correspond to the computational basis</span>
<span class="sd">        compBasisDim (int): Dimension of the computational basis</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">numPhotons</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">numModes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">numLayers</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">varphi</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
        <span class="n">burnoutMap</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">alphaWG</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">std_alphaWG</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">std_SR</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ellMZI</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.028668</span><span class="p">,</span>
        <span class="n">ellPS</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0050</span><span class="p">,</span>
        <span class="n">ellF</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.028668</span><span class="p">,</span>
        <span class="n">trainingSet</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialization of a QPNN instance.</span>

<span class="sd">        The characteristics of the QPNN are first stored, and others are computed from those</span>
<span class="sd">        provided. Then, the specifications are used to construct the pieces of the network,</span>
<span class="sd">        layer by layer. For each layer, a Clements MZI mesh is instantiated, and any losses</span>
<span class="sd">        or imperfect directional coupler splitting ratios for each mesh are stored in the</span>
<span class="sd">        attributes of the QPNN instance. Between pairs of layers, single-site nonlinearity</span>
<span class="sd">        functions are built according to the provided effective nonlinear phase shift,</span>
<span class="sd">        $\\varphi$, and `burnoutMap`.</span>

<span class="sd">        Args:</span>
<span class="sd">            numPhotons: Number of photons, $n$</span>
<span class="sd">            numModes: Number of optical modes, $m$</span>
<span class="sd">            numLayers: Number of layers, $L$</span>
<span class="sd">            varphi: Effective nonlinear phase shift, $\\varphi$</span>
<span class="sd">            burnoutMap: A 1D array of length $m$, with either boolean or binary elements, specifying whether nonlinearities are on/off for specific modes</span>
<span class="sd">            alphaWG: Mean propagation losses, $\\alpha_\\mathrm{WG}$, in $\\text{dB}/\\text{cm}$</span>
<span class="sd">            std_alphaWG: Standard deviation of the propagation losses, $\\alpha_\\mathrm{WG}$, in $\\text{dB}/\\text{cm}$</span>
<span class="sd">            std_SR: Standard deviation of the directional coupler splitting ratio, $t$</span>
<span class="sd">            ellMZI: Characteristic length of a MZI, $\\ell_\\mathrm{MZI}$, in $\\text{cm}$</span>
<span class="sd">            ellPS: Characteristic length of a phase shifter, $\\ell_\\mathrm{PS}$, in $\\text{cm}$</span>
<span class="sd">            ellF: Characteristic length of a flat section in parallel with a MZI, $\\ell_\\mathrm{F}$, in $\\text{cm}$</span>
<span class="sd">            trainingSet: A tuple including the number of input-output pairs, $K$, a 2D $N\\times K$ array of the input states resolved in the Fock basis, and a 2D $N\\times K$ array of the corresponding output states resolved in the Fock basis</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Store the provided properties of the QPNN, calculate others</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numPhotons</span> <span class="o">=</span> <span class="n">numPhotons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">=</span> <span class="n">numModes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numLayers</span> <span class="o">=</span> <span class="n">numLayers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fockDim</span> <span class="o">=</span> <span class="n">getDim</span><span class="p">(</span><span class="n">numPhotons</span><span class="p">,</span> <span class="n">numModes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pspl</span> <span class="o">=</span> <span class="n">numModes</span> <span class="o">*</span> <span class="n">numModes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alphaWG</span> <span class="o">=</span> <span class="n">alphaWG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std_alphaWG</span> <span class="o">=</span> <span class="n">std_alphaWG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std_SR</span> <span class="o">=</span> <span class="n">std_SR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ellMZI</span> <span class="o">=</span> <span class="n">ellMZI</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ellPS</span> <span class="o">=</span> <span class="n">ellPS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ellF</span> <span class="o">=</span> <span class="n">ellF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">varphi</span> <span class="o">=</span> <span class="n">varphi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">burnoutMap</span> <span class="o">=</span> <span class="n">burnoutMap</span>
        <span class="k">if</span> <span class="n">burnoutMap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">burnoutMap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">numModes</span><span class="p">,</span> <span class="n">numLayers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">trainingSet</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">psiIn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">psiOut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="n">trainingSet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">psiIn</span> <span class="o">=</span> <span class="n">trainingSet</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">psiOut</span> <span class="o">=</span> <span class="n">trainingSet</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Initialize phases, S, Func, Fcon, Pcb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allPhases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numModes</span> <span class="o">*</span> <span class="n">numModes</span> <span class="o">*</span> <span class="n">numLayers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fockDim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Func</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Fcon</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Pcb</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Create the network from MZI meshes and single-site nonlinearities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alphas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SRs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kerrU</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numLayers</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">Mesh</span><span class="p">(</span>
                    <span class="n">numModes</span><span class="p">,</span>
                    <span class="n">alphaWG</span><span class="o">=</span><span class="n">alphaWG</span><span class="p">,</span>
                    <span class="n">std_alphaWG</span><span class="o">=</span><span class="n">std_alphaWG</span><span class="p">,</span>
                    <span class="n">std_SR</span><span class="o">=</span><span class="n">std_SR</span><span class="p">,</span>
                    <span class="n">ellMZI</span><span class="o">=</span><span class="n">ellMZI</span><span class="p">,</span>
                    <span class="n">ellPS</span><span class="o">=</span><span class="n">ellPS</span><span class="p">,</span>
                    <span class="n">ellF</span><span class="o">=</span><span class="n">ellF</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># Store the losses and DC splitting ratios generated when instantiating the meshes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alphas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">[</span><span class="n">L</span><span class="p">]</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SRs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">[</span><span class="n">L</span><span class="p">]</span><span class="o">.</span><span class="n">SR</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">L</span> <span class="o">&lt;</span> <span class="n">numLayers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kerrU</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">buildKerrUnitary</span><span class="p">(</span><span class="n">numPhotons</span><span class="p">,</span> <span class="n">numModes</span><span class="p">,</span> <span class="n">varphi</span><span class="p">,</span> <span class="n">burnoutMap</span><span class="p">[:,</span> <span class="n">L</span><span class="p">]))</span>

        <span class="c1"># Extract the indices of the Fock basis states that correspond to the computational basis</span>
        <span class="k">if</span> <span class="n">numModes</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compBasisInds</span> <span class="o">=</span> <span class="n">compBasisIndices</span><span class="p">(</span><span class="n">numPhotons</span><span class="p">,</span> <span class="n">numModes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compBasisInds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compBasisDim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compBasisInds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_phases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allPhases</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set all phase shifts in the QPNN.</span>

<span class="sd">        A QPNN features $L$ layers, and thus $L$ Clements MZI meshes, each</span>
<span class="sd">        with $m$ optical modes and $m^2$ phase shifts. Out of the total $m^2L$</span>
<span class="sd">        phase shifts, input, they are separated by layer and passed to the</span>
<span class="sd">        meshes that were instantiated for the network model upon initialization.</span>

<span class="sd">        Args:</span>
<span class="sd">            allPhases: A 1D array of length $m^2L$ with all the phase shift parameters for the network</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Separate the phases by layer, then add to respective mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allPhases</span> <span class="o">=</span> <span class="n">allPhases</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numLayers</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">[</span><span class="n">L</span><span class="p">]</span><span class="o">.</span><span class="n">set_phases</span><span class="p">(</span><span class="n">allPhases</span><span class="p">[</span><span class="n">L</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pspl</span> <span class="p">:</span> <span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pspl</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">set_alphas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alphas</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set all component losses in the QPNN.</span>

<span class="sd">        A QPNN features $L$ layers, and thus $L$ Clements MZI meshes, each</span>
<span class="sd">        with $m$ optical modes, $\\frac{1}{2}m(m-1)$ MZIs, $m$ flat sections</span>
<span class="sd">        in parallel with MZIs, and $m$ output phase shifters. Each component</span>
<span class="sd">        contributes a specific fraction of light lost when photons propagate</span>
<span class="sd">        through them. The MZIs may have imbalanced losses in each arm, and</span>
<span class="sd">        thus there are two values for the fraction of light lost per MZI.</span>
<span class="sd">        Here, all of the fractions can be specified manually by inputting a</span>
<span class="sd">        list of lists of $\\alpha$ values for each layer. These are then</span>
<span class="sd">        passed to the corresponding meshes that were instantiated for the</span>
<span class="sd">        network model upon initialization.</span>

<span class="sd">        Args:</span>
<span class="sd">            alphas: An $L$-element list of 1D arrays of length $m(m-1) + 2m$ that respectively provide the fractions of light lost contributed by each component in each layer of the QPNN</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Separate the alphas by layer, then add to respective mesh</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numLayers</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">[</span><span class="n">L</span><span class="p">]</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alphas</span><span class="p">[</span><span class="n">L</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alphas</span> <span class="o">=</span> <span class="n">alphas</span>

    <span class="k">def</span> <span class="nf">set_SRs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SRs</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set all directional coupler splitting ratios in the QPNN.</span>

<span class="sd">        A QPNN features $L$ layers, and thus $L$ Clements MZI meshes, each</span>
<span class="sd">        with $m$ optical modes, $\\frac{1}{2}m(m-1)$ MZIs, and thus $m(m-1)$</span>
<span class="sd">        directional couplers. Each directional coupler may have a specific</span>
<span class="sd">        splitting ratio. Here, each ratio can be specified manually by</span>
<span class="sd">        inputting a list of lists of $t$ values for each layer. These are</span>
<span class="sd">        then passed to the corresponding meshes that were instantiated for</span>
<span class="sd">        the network model.</span>

<span class="sd">        Args:</span>
<span class="sd">            SRs: An $L$-element list of 1D arrays of length $m(m-1)$ that respectively provide the splitting ratios, $t$, for each directional coupler in each layer of the QPNN</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Separate the splitting ratios by layer, then add to respective mesh</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numLayers</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">[</span><span class="n">L</span><span class="p">]</span><span class="o">.</span><span class="n">set_SR</span><span class="p">(</span><span class="n">SRs</span><span class="p">[</span><span class="n">L</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SRs</span> <span class="o">=</span> <span class="n">SRs</span>

    <span class="k">def</span> <span class="nf">sysFunc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the system transfer function, $\\mathbf{S}$, of the QPNN.</span>

<span class="sd">        An example QPNN, with two layers, two photons, and four optical modes,</span>
<span class="sd">        is shown below. This function computes the matrix representation of the</span>
<span class="sd">        QPNN, like the one shown below, from the pieces of the architecture.</span>

<span class="sd">        &lt;p align=&quot;center&quot;&gt;</span>
<span class="sd">        &lt;img width=&quot;800&quot; src=&quot;img/qpnn.png&quot;&gt;</span>
<span class="sd">        &lt;/p&gt;</span>

<span class="sd">        Mathematically, the system function is given by,</span>

<span class="sd">        $$ \\mathbf{S} = \\mathbf{U}(\\boldsymbol{\\phi}_L, \\boldsymbol{\\theta}_L) \\cdot</span>
<span class="sd">        \\prod_{i=1}^{L-1}\\boldsymbol{\\Sigma}(\\varphi) \\cdot</span>
<span class="sd">        \\mathbf{U}(\\boldsymbol{\\phi}_i, \\boldsymbol{\\theta}_i), $$</span>

<span class="sd">        where $\\mathbf{U}(\\boldsymbol{\\phi}_i, \\boldsymbol{\\theta}_i)$</span>
<span class="sd">        is the Clements MZI mesh for the $i^\\text{th}$ layer and</span>
<span class="sd">        $\\boldsymbol{\\Sigma}(\\varphi)$ represents a section of single-site</span>
<span class="sd">        Kerr nonlinearities. Note that this equation is not fully correct when</span>
<span class="sd">        certain nonlinearities are *burnt out*.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A 2D array, the $N\\times N$ matrix representation of the QPNN resolved in the Fock basis</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fockDim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numLayers</span><span class="p">):</span>
            <span class="c1"># Encode the single-photon unitary</span>
            <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">[</span><span class="n">L</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

            <span class="c1"># Construct the multi-photon unitary</span>
            <span class="n">PhiU</span> <span class="o">=</span> <span class="n">multiPhotonUnitary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numPhotons</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>

            <span class="c1"># Apply the single-site Kerr nonlinearities</span>
            <span class="k">if</span> <span class="n">L</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">numLayers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">PhiU</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kerrU</span><span class="p">[</span><span class="n">L</span><span class="p">],</span> <span class="n">PhiU</span><span class="p">)</span>

            <span class="c1"># Update the full system matrix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">PhiU</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>

    <span class="k">def</span> <span class="nf">calculate_Func</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the unconditional fidelity, $\\mathcal{F}^\\mathrm{(unc)}$, of the QPNN.</span>

<span class="sd">        INSERT DOCUMENTATION HERE</span>
<span class="sd">        ADD TEST</span>

<span class="sd">        Returns:</span>
<span class="sd">            The unconditional fidelity, $\\mathcal{F}^\\mathrm{(unc)}$, of the QPNN.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check that a training set has been provided</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;No training set was provided for this QPNN instance.&quot;</span>

        <span class="c1"># Compute the unconditional fidelity for each input-output pair, then average</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Func</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
            <span class="n">psiO</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psiOut</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">psiI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiIn</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Func</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">psiO</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">psiI</span><span class="p">))</span> <span class="o">**</span> <span class="mf">2.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Func</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Func</span>

    <span class="k">def</span> <span class="nf">calculate_Fcon</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the conditional fidelity, $\\mathcal{F}^\\mathrm{(con)}$, of the QPNN.</span>

<span class="sd">        INSERT DOCUMENTATION HERE AND IN THE CODE</span>
<span class="sd">        ADD TEST</span>

<span class="sd">        Returns:</span>
<span class="sd">            The conditional fidelity, $\\mathcal{F}^\\mathrm{(con)}$, of the QPNN.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check that a training set has been provided</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;No training set was provided for this QPNN instance.&quot;</span>

        <span class="c1"># Check that dual-rail encoding is assumed with no missing qubits</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">numPhotons</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;This function is designed only for dual-rail encoding where no qubits are missing.&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Fcon</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
            <span class="n">psiOut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiIn</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span>
            <span class="n">psiIdeal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiOut</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span>

            <span class="n">psiOut_CB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compBasisDim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">psiIdeal_CB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compBasisDim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

            <span class="n">Aout</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">Aideal</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">s_CB</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compBasisInds</span><span class="p">):</span>
                <span class="n">Aout</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">psiOut</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="o">**</span> <span class="mf">2.0</span>
                <span class="n">Aideal</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">psiIdeal</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="o">**</span> <span class="mf">2.0</span>

                <span class="n">psiOut_CB</span><span class="p">[</span><span class="n">s_CB</span><span class="p">]</span> <span class="o">=</span> <span class="n">psiOut</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                <span class="n">psiIdeal_CB</span><span class="p">[</span><span class="n">s_CB</span><span class="p">]</span> <span class="o">=</span> <span class="n">psiIdeal</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="n">psiOut_CB</span> <span class="o">=</span> <span class="n">psiOut_CB</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Aout</span><span class="p">)</span>
            <span class="n">psiIdeal_CB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">psiIdeal_CB</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Aideal</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">Fcon</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">psiIdeal_CB</span><span class="p">,</span> <span class="n">psiOut_CB</span><span class="p">))</span> <span class="o">**</span> <span class="mf">2.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Fcon</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fcon</span>

    <span class="k">def</span> <span class="nf">calculate_Pcb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the conditional fidelity, $\\mathcal{P}^\\mathrm{(cb)}$, of the QPNN.</span>

<span class="sd">        INSERT DOCUMENTATION HERE AND IN THE CODE</span>
<span class="sd">        ADD TEST</span>

<span class="sd">        Returns:</span>
<span class="sd">            The computational basis probability, $\\mathcal{P}^\\mathrm{(cb)}$, of the QPNN.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check that a training set has been provided</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;No training set was provided for this QPNN instance.&quot;</span>

        <span class="c1"># Check that dual-rail encoding is assumed with no missing qubits</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">numPhotons</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;This function is designed only for dual-rail encoding where no qubits are missing.&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Pcb</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
            <span class="n">psiOut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiIn</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">compBasisInds</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Pcb</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">psiOut</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="o">**</span> <span class="mf">2.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Pcb</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pcb</span>
</code></pre></div></td></tr></table></div>
        </details>

  

  <div class="doc doc-children">









<div class="doc doc-object doc-function">



<h3 id="quotonic.qpnn.QPNN.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">numPhotons</span><span class="p">,</span> <span class="n">numModes</span><span class="p">,</span> <span class="n">numLayers</span><span class="p">,</span> <span class="n">varphi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">burnoutMap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alphaWG</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">std_alphaWG</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">std_SR</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ellMZI</span><span class="o">=</span><span class="mf">0.028668</span><span class="p">,</span> <span class="n">ellPS</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">ellF</span><span class="o">=</span><span class="mf">0.028668</span><span class="p">,</span> <span class="n">trainingSet</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

<a href="#quotonic.qpnn.QPNN.__init__" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Initialization of a QPNN instance.</p>
<p>The characteristics of the QPNN are first stored, and others are computed from those
provided. Then, the specifications are used to construct the pieces of the network,
layer by layer. For each layer, a Clements MZI mesh is instantiated, and any losses
or imperfect directional coupler splitting ratios for each mesh are stored in the
attributes of the QPNN instance. Between pairs of layers, single-site nonlinearity
functions are built according to the provided effective nonlinear phase shift,
<span class="arithmatex">\(\varphi\)</span>, and <code>burnoutMap</code>.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>numPhotons</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Number of photons, <span class="arithmatex">\(n\)</span></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>numModes</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Number of optical modes, <span class="arithmatex">\(m\)</span></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>numLayers</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Number of layers, <span class="arithmatex">\(L\)</span></p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>varphi</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Effective nonlinear phase shift, <span class="arithmatex">\(\varphi\)</span></p></td>
          <td>
                <code>np.pi</code>
          </td>
        </tr>
        <tr>
          <td><code>burnoutMap</code></td>
          <td>
                <code><span title="typing.Optional">Optional</span>[<span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span>]</code>
          </td>
          <td><p>A 1D array of length <span class="arithmatex">\(m\)</span>, with either boolean or binary elements, specifying whether nonlinearities are on/off for specific modes</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>alphaWG</code></td>
          <td>
                <code><span title="typing.Optional">Optional</span>[float]</code>
          </td>
          <td><p>Mean propagation losses, <span class="arithmatex">\(\alpha_\mathrm{WG}\)</span>, in <span class="arithmatex">\(\text{dB}/\text{cm}\)</span></p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>std_alphaWG</code></td>
          <td>
                <code><span title="typing.Optional">Optional</span>[float]</code>
          </td>
          <td><p>Standard deviation of the propagation losses, <span class="arithmatex">\(\alpha_\mathrm{WG}\)</span>, in <span class="arithmatex">\(\text{dB}/\text{cm}\)</span></p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>std_SR</code></td>
          <td>
                <code><span title="typing.Optional">Optional</span>[float]</code>
          </td>
          <td><p>Standard deviation of the directional coupler splitting ratio, <span class="arithmatex">\(t\)</span></p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>ellMZI</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Characteristic length of a MZI, <span class="arithmatex">\(\ell_\mathrm{MZI}\)</span>, in <span class="arithmatex">\(\text{cm}\)</span></p></td>
          <td>
                <code>0.028668</code>
          </td>
        </tr>
        <tr>
          <td><code>ellPS</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Characteristic length of a phase shifter, <span class="arithmatex">\(\ell_\mathrm{PS}\)</span>, in <span class="arithmatex">\(\text{cm}\)</span></p></td>
          <td>
                <code>0.005</code>
          </td>
        </tr>
        <tr>
          <td><code>ellF</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Characteristic length of a flat section in parallel with a MZI, <span class="arithmatex">\(\ell_\mathrm{F}\)</span>, in <span class="arithmatex">\(\text{cm}\)</span></p></td>
          <td>
                <code>0.028668</code>
          </td>
        </tr>
        <tr>
          <td><code>trainingSet</code></td>
          <td>
                <code><span title="typing.Optional">Optional</span>[tuple]</code>
          </td>
          <td><p>A tuple including the number of input-output pairs, <span class="arithmatex">\(K\)</span>, a 2D <span class="arithmatex">\(N\times K\)</span> array of the input states resolved in the Fock basis, and a 2D <span class="arithmatex">\(N\times K\)</span> array of the corresponding output states resolved in the Fock basis</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>quotonic/qpnn.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">numPhotons</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">numModes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">numLayers</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">varphi</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
    <span class="n">burnoutMap</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">alphaWG</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">std_alphaWG</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">std_SR</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ellMZI</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.028668</span><span class="p">,</span>
    <span class="n">ellPS</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0050</span><span class="p">,</span>
    <span class="n">ellF</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.028668</span><span class="p">,</span>
    <span class="n">trainingSet</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialization of a QPNN instance.</span>

<span class="sd">    The characteristics of the QPNN are first stored, and others are computed from those</span>
<span class="sd">    provided. Then, the specifications are used to construct the pieces of the network,</span>
<span class="sd">    layer by layer. For each layer, a Clements MZI mesh is instantiated, and any losses</span>
<span class="sd">    or imperfect directional coupler splitting ratios for each mesh are stored in the</span>
<span class="sd">    attributes of the QPNN instance. Between pairs of layers, single-site nonlinearity</span>
<span class="sd">    functions are built according to the provided effective nonlinear phase shift,</span>
<span class="sd">    $\\varphi$, and `burnoutMap`.</span>

<span class="sd">    Args:</span>
<span class="sd">        numPhotons: Number of photons, $n$</span>
<span class="sd">        numModes: Number of optical modes, $m$</span>
<span class="sd">        numLayers: Number of layers, $L$</span>
<span class="sd">        varphi: Effective nonlinear phase shift, $\\varphi$</span>
<span class="sd">        burnoutMap: A 1D array of length $m$, with either boolean or binary elements, specifying whether nonlinearities are on/off for specific modes</span>
<span class="sd">        alphaWG: Mean propagation losses, $\\alpha_\\mathrm{WG}$, in $\\text{dB}/\\text{cm}$</span>
<span class="sd">        std_alphaWG: Standard deviation of the propagation losses, $\\alpha_\\mathrm{WG}$, in $\\text{dB}/\\text{cm}$</span>
<span class="sd">        std_SR: Standard deviation of the directional coupler splitting ratio, $t$</span>
<span class="sd">        ellMZI: Characteristic length of a MZI, $\\ell_\\mathrm{MZI}$, in $\\text{cm}$</span>
<span class="sd">        ellPS: Characteristic length of a phase shifter, $\\ell_\\mathrm{PS}$, in $\\text{cm}$</span>
<span class="sd">        ellF: Characteristic length of a flat section in parallel with a MZI, $\\ell_\\mathrm{F}$, in $\\text{cm}$</span>
<span class="sd">        trainingSet: A tuple including the number of input-output pairs, $K$, a 2D $N\\times K$ array of the input states resolved in the Fock basis, and a 2D $N\\times K$ array of the corresponding output states resolved in the Fock basis</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Store the provided properties of the QPNN, calculate others</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">numPhotons</span> <span class="o">=</span> <span class="n">numPhotons</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">=</span> <span class="n">numModes</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">numLayers</span> <span class="o">=</span> <span class="n">numLayers</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">fockDim</span> <span class="o">=</span> <span class="n">getDim</span><span class="p">(</span><span class="n">numPhotons</span><span class="p">,</span> <span class="n">numModes</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pspl</span> <span class="o">=</span> <span class="n">numModes</span> <span class="o">*</span> <span class="n">numModes</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">alphaWG</span> <span class="o">=</span> <span class="n">alphaWG</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">std_alphaWG</span> <span class="o">=</span> <span class="n">std_alphaWG</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">std_SR</span> <span class="o">=</span> <span class="n">std_SR</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ellMZI</span> <span class="o">=</span> <span class="n">ellMZI</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ellPS</span> <span class="o">=</span> <span class="n">ellPS</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ellF</span> <span class="o">=</span> <span class="n">ellF</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">varphi</span> <span class="o">=</span> <span class="n">varphi</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">burnoutMap</span> <span class="o">=</span> <span class="n">burnoutMap</span>
    <span class="k">if</span> <span class="n">burnoutMap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">burnoutMap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">numModes</span><span class="p">,</span> <span class="n">numLayers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">trainingSet</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psiIn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psiOut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="n">trainingSet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psiIn</span> <span class="o">=</span> <span class="n">trainingSet</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psiOut</span> <span class="o">=</span> <span class="n">trainingSet</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># Initialize phases, S, Func, Fcon, Pcb</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">allPhases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numModes</span> <span class="o">*</span> <span class="n">numModes</span> <span class="o">*</span> <span class="n">numLayers</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fockDim</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Func</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Fcon</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Pcb</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># Create the network from MZI meshes and single-site nonlinearities</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">alphas</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">SRs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">kerrU</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numLayers</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">Mesh</span><span class="p">(</span>
                <span class="n">numModes</span><span class="p">,</span>
                <span class="n">alphaWG</span><span class="o">=</span><span class="n">alphaWG</span><span class="p">,</span>
                <span class="n">std_alphaWG</span><span class="o">=</span><span class="n">std_alphaWG</span><span class="p">,</span>
                <span class="n">std_SR</span><span class="o">=</span><span class="n">std_SR</span><span class="p">,</span>
                <span class="n">ellMZI</span><span class="o">=</span><span class="n">ellMZI</span><span class="p">,</span>
                <span class="n">ellPS</span><span class="o">=</span><span class="n">ellPS</span><span class="p">,</span>
                <span class="n">ellF</span><span class="o">=</span><span class="n">ellF</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Store the losses and DC splitting ratios generated when instantiating the meshes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alphas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">[</span><span class="n">L</span><span class="p">]</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SRs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">[</span><span class="n">L</span><span class="p">]</span><span class="o">.</span><span class="n">SR</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">L</span> <span class="o">&lt;</span> <span class="n">numLayers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kerrU</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">buildKerrUnitary</span><span class="p">(</span><span class="n">numPhotons</span><span class="p">,</span> <span class="n">numModes</span><span class="p">,</span> <span class="n">varphi</span><span class="p">,</span> <span class="n">burnoutMap</span><span class="p">[:,</span> <span class="n">L</span><span class="p">]))</span>

    <span class="c1"># Extract the indices of the Fock basis states that correspond to the computational basis</span>
    <span class="k">if</span> <span class="n">numModes</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compBasisInds</span> <span class="o">=</span> <span class="n">compBasisIndices</span><span class="p">(</span><span class="n">numPhotons</span><span class="p">,</span> <span class="n">numModes</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compBasisInds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">compBasisDim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compBasisInds</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="quotonic.qpnn.QPNN.calculate_Fcon" class="doc doc-heading">
<code class="highlight language-python"><span class="n">calculate_Fcon</span><span class="p">()</span></code>

<a href="#quotonic.qpnn.QPNN.calculate_Fcon" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Compute the conditional fidelity, <span class="arithmatex">\(\mathcal{F}^\mathrm{(con)}\)</span>, of the QPNN.</p>
<p>INSERT DOCUMENTATION HERE AND IN THE CODE
ADD TEST</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>float</code>
          </td>
          <td><p>The conditional fidelity, <span class="arithmatex">\(\mathcal{F}^\mathrm{(con)}\)</span>, of the QPNN.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>quotonic/qpnn.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">calculate_Fcon</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the conditional fidelity, $\\mathcal{F}^\\mathrm{(con)}$, of the QPNN.</span>

<span class="sd">    INSERT DOCUMENTATION HERE AND IN THE CODE</span>
<span class="sd">    ADD TEST</span>

<span class="sd">    Returns:</span>
<span class="sd">        The conditional fidelity, $\\mathcal{F}^\\mathrm{(con)}$, of the QPNN.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check that a training set has been provided</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;No training set was provided for this QPNN instance.&quot;</span>

    <span class="c1"># Check that dual-rail encoding is assumed with no missing qubits</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">numPhotons</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;This function is designed only for dual-rail encoding where no qubits are missing.&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">Fcon</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
        <span class="n">psiOut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiIn</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span>
        <span class="n">psiIdeal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiOut</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span>

        <span class="n">psiOut_CB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compBasisDim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">psiIdeal_CB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compBasisDim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

        <span class="n">Aout</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">Aideal</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">s_CB</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compBasisInds</span><span class="p">):</span>
            <span class="n">Aout</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">psiOut</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="o">**</span> <span class="mf">2.0</span>
            <span class="n">Aideal</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">psiIdeal</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="o">**</span> <span class="mf">2.0</span>

            <span class="n">psiOut_CB</span><span class="p">[</span><span class="n">s_CB</span><span class="p">]</span> <span class="o">=</span> <span class="n">psiOut</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="n">psiIdeal_CB</span><span class="p">[</span><span class="n">s_CB</span><span class="p">]</span> <span class="o">=</span> <span class="n">psiIdeal</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
        <span class="n">psiOut_CB</span> <span class="o">=</span> <span class="n">psiOut_CB</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Aout</span><span class="p">)</span>
        <span class="n">psiIdeal_CB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">psiIdeal_CB</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Aideal</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Fcon</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">psiIdeal_CB</span><span class="p">,</span> <span class="n">psiOut_CB</span><span class="p">))</span> <span class="o">**</span> <span class="mf">2.0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Fcon</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fcon</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="quotonic.qpnn.QPNN.calculate_Func" class="doc doc-heading">
<code class="highlight language-python"><span class="n">calculate_Func</span><span class="p">()</span></code>

<a href="#quotonic.qpnn.QPNN.calculate_Func" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Compute the unconditional fidelity, <span class="arithmatex">\(\mathcal{F}^\mathrm{(unc)}\)</span>, of the QPNN.</p>
<p>INSERT DOCUMENTATION HERE
ADD TEST</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>float</code>
          </td>
          <td><p>The unconditional fidelity, <span class="arithmatex">\(\mathcal{F}^\mathrm{(unc)}\)</span>, of the QPNN.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>quotonic/qpnn.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">calculate_Func</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the unconditional fidelity, $\\mathcal{F}^\\mathrm{(unc)}$, of the QPNN.</span>

<span class="sd">    INSERT DOCUMENTATION HERE</span>
<span class="sd">    ADD TEST</span>

<span class="sd">    Returns:</span>
<span class="sd">        The unconditional fidelity, $\\mathcal{F}^\\mathrm{(unc)}$, of the QPNN.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check that a training set has been provided</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;No training set was provided for this QPNN instance.&quot;</span>

    <span class="c1"># Compute the unconditional fidelity for each input-output pair, then average</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Func</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
        <span class="n">psiO</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psiOut</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">psiI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiIn</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Func</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">psiO</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">psiI</span><span class="p">))</span> <span class="o">**</span> <span class="mf">2.0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Func</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Func</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="quotonic.qpnn.QPNN.calculate_Pcb" class="doc doc-heading">
<code class="highlight language-python"><span class="n">calculate_Pcb</span><span class="p">()</span></code>

<a href="#quotonic.qpnn.QPNN.calculate_Pcb" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Compute the conditional fidelity, <span class="arithmatex">\(\mathcal{P}^\mathrm{(cb)}\)</span>, of the QPNN.</p>
<p>INSERT DOCUMENTATION HERE AND IN THE CODE
ADD TEST</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>float</code>
          </td>
          <td><p>The computational basis probability, <span class="arithmatex">\(\mathcal{P}^\mathrm{(cb)}\)</span>, of the QPNN.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>quotonic/qpnn.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">calculate_Pcb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the conditional fidelity, $\\mathcal{P}^\\mathrm{(cb)}$, of the QPNN.</span>

<span class="sd">    INSERT DOCUMENTATION HERE AND IN THE CODE</span>
<span class="sd">    ADD TEST</span>

<span class="sd">    Returns:</span>
<span class="sd">        The computational basis probability, $\\mathcal{P}^\\mathrm{(cb)}$, of the QPNN.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check that a training set has been provided</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;No training set was provided for this QPNN instance.&quot;</span>

    <span class="c1"># Check that dual-rail encoding is assumed with no missing qubits</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">numModes</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">numPhotons</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;This function is designed only for dual-rail encoding where no qubits are missing.&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">Pcb</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
        <span class="n">psiOut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiIn</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">compBasisInds</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Pcb</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">psiOut</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="o">**</span> <span class="mf">2.0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Pcb</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pcb</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="quotonic.qpnn.QPNN.set_SRs" class="doc doc-heading">
<code class="highlight language-python"><span class="n">set_SRs</span><span class="p">(</span><span class="n">SRs</span><span class="p">)</span></code>

<a href="#quotonic.qpnn.QPNN.set_SRs" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Set all directional coupler splitting ratios in the QPNN.</p>
<p>A QPNN features <span class="arithmatex">\(L\)</span> layers, and thus <span class="arithmatex">\(L\)</span> Clements MZI meshes, each
with <span class="arithmatex">\(m\)</span> optical modes, <span class="arithmatex">\(\frac{1}{2}m(m-1)\)</span> MZIs, and thus <span class="arithmatex">\(m(m-1)\)</span>
directional couplers. Each directional coupler may have a specific
splitting ratio. Here, each ratio can be specified manually by
inputting a list of lists of <span class="arithmatex">\(t\)</span> values for each layer. These are
then passed to the corresponding meshes that were instantiated for
the network model.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>SRs</code></td>
          <td>
                <code>list</code>
          </td>
          <td><p>An <span class="arithmatex">\(L\)</span>-element list of 1D arrays of length <span class="arithmatex">\(m(m-1)\)</span> that respectively provide the splitting ratios, <span class="arithmatex">\(t\)</span>, for each directional coupler in each layer of the QPNN</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>quotonic/qpnn.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">set_SRs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SRs</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set all directional coupler splitting ratios in the QPNN.</span>

<span class="sd">    A QPNN features $L$ layers, and thus $L$ Clements MZI meshes, each</span>
<span class="sd">    with $m$ optical modes, $\\frac{1}{2}m(m-1)$ MZIs, and thus $m(m-1)$</span>
<span class="sd">    directional couplers. Each directional coupler may have a specific</span>
<span class="sd">    splitting ratio. Here, each ratio can be specified manually by</span>
<span class="sd">    inputting a list of lists of $t$ values for each layer. These are</span>
<span class="sd">    then passed to the corresponding meshes that were instantiated for</span>
<span class="sd">    the network model.</span>

<span class="sd">    Args:</span>
<span class="sd">        SRs: An $L$-element list of 1D arrays of length $m(m-1)$ that respectively provide the splitting ratios, $t$, for each directional coupler in each layer of the QPNN</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Separate the splitting ratios by layer, then add to respective mesh</span>
    <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numLayers</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">[</span><span class="n">L</span><span class="p">]</span><span class="o">.</span><span class="n">set_SR</span><span class="p">(</span><span class="n">SRs</span><span class="p">[</span><span class="n">L</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">SRs</span> <span class="o">=</span> <span class="n">SRs</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="quotonic.qpnn.QPNN.set_alphas" class="doc doc-heading">
<code class="highlight language-python"><span class="n">set_alphas</span><span class="p">(</span><span class="n">alphas</span><span class="p">)</span></code>

<a href="#quotonic.qpnn.QPNN.set_alphas" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Set all component losses in the QPNN.</p>
<p>A QPNN features <span class="arithmatex">\(L\)</span> layers, and thus <span class="arithmatex">\(L\)</span> Clements MZI meshes, each
with <span class="arithmatex">\(m\)</span> optical modes, <span class="arithmatex">\(\frac{1}{2}m(m-1)\)</span> MZIs, <span class="arithmatex">\(m\)</span> flat sections
in parallel with MZIs, and <span class="arithmatex">\(m\)</span> output phase shifters. Each component
contributes a specific fraction of light lost when photons propagate
through them. The MZIs may have imbalanced losses in each arm, and
thus there are two values for the fraction of light lost per MZI.
Here, all of the fractions can be specified manually by inputting a
list of lists of <span class="arithmatex">\(\alpha\)</span> values for each layer. These are then
passed to the corresponding meshes that were instantiated for the
network model upon initialization.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>alphas</code></td>
          <td>
                <code>list</code>
          </td>
          <td><p>An <span class="arithmatex">\(L\)</span>-element list of 1D arrays of length <span class="arithmatex">\(m(m-1) + 2m\)</span> that respectively provide the fractions of light lost contributed by each component in each layer of the QPNN</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>quotonic/qpnn.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">set_alphas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alphas</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set all component losses in the QPNN.</span>

<span class="sd">    A QPNN features $L$ layers, and thus $L$ Clements MZI meshes, each</span>
<span class="sd">    with $m$ optical modes, $\\frac{1}{2}m(m-1)$ MZIs, $m$ flat sections</span>
<span class="sd">    in parallel with MZIs, and $m$ output phase shifters. Each component</span>
<span class="sd">    contributes a specific fraction of light lost when photons propagate</span>
<span class="sd">    through them. The MZIs may have imbalanced losses in each arm, and</span>
<span class="sd">    thus there are two values for the fraction of light lost per MZI.</span>
<span class="sd">    Here, all of the fractions can be specified manually by inputting a</span>
<span class="sd">    list of lists of $\\alpha$ values for each layer. These are then</span>
<span class="sd">    passed to the corresponding meshes that were instantiated for the</span>
<span class="sd">    network model upon initialization.</span>

<span class="sd">    Args:</span>
<span class="sd">        alphas: An $L$-element list of 1D arrays of length $m(m-1) + 2m$ that respectively provide the fractions of light lost contributed by each component in each layer of the QPNN</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Separate the alphas by layer, then add to respective mesh</span>
    <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numLayers</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">[</span><span class="n">L</span><span class="p">]</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alphas</span><span class="p">[</span><span class="n">L</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">alphas</span> <span class="o">=</span> <span class="n">alphas</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="quotonic.qpnn.QPNN.set_phases" class="doc doc-heading">
<code class="highlight language-python"><span class="n">set_phases</span><span class="p">(</span><span class="n">allPhases</span><span class="p">)</span></code>

<a href="#quotonic.qpnn.QPNN.set_phases" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Set all phase shifts in the QPNN.</p>
<p>A QPNN features <span class="arithmatex">\(L\)</span> layers, and thus <span class="arithmatex">\(L\)</span> Clements MZI meshes, each
with <span class="arithmatex">\(m\)</span> optical modes and <span class="arithmatex">\(m^2\)</span> phase shifts. Out of the total <span class="arithmatex">\(m^2L\)</span>
phase shifts, input, they are separated by layer and passed to the
meshes that were instantiated for the network model upon initialization.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>allPhases</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A 1D array of length <span class="arithmatex">\(m^2L\)</span> with all the phase shift parameters for the network</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>quotonic/qpnn.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">set_phases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allPhases</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set all phase shifts in the QPNN.</span>

<span class="sd">    A QPNN features $L$ layers, and thus $L$ Clements MZI meshes, each</span>
<span class="sd">    with $m$ optical modes and $m^2$ phase shifts. Out of the total $m^2L$</span>
<span class="sd">    phase shifts, input, they are separated by layer and passed to the</span>
<span class="sd">    meshes that were instantiated for the network model upon initialization.</span>

<span class="sd">    Args:</span>
<span class="sd">        allPhases: A 1D array of length $m^2L$ with all the phase shift parameters for the network</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Separate the phases by layer, then add to respective mesh</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">allPhases</span> <span class="o">=</span> <span class="n">allPhases</span>
    <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numLayers</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">[</span><span class="n">L</span><span class="p">]</span><span class="o">.</span><span class="n">set_phases</span><span class="p">(</span><span class="n">allPhases</span><span class="p">[</span><span class="n">L</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pspl</span> <span class="p">:</span> <span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pspl</span><span class="p">])</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="quotonic.qpnn.QPNN.sysFunc" class="doc doc-heading">
<code class="highlight language-python"><span class="n">sysFunc</span><span class="p">()</span></code>

<a href="#quotonic.qpnn.QPNN.sysFunc" class="headerlink" title="Permanent link">&para;</a></h3>


  <div class="doc doc-contents ">
  
      <p>Compute the system transfer function, <span class="arithmatex">\(\mathbf{S}\)</span>, of the QPNN.</p>
<p>An example QPNN, with two layers, two photons, and four optical modes,
is shown below. This function computes the matrix representation of the
QPNN, like the one shown below, from the pieces of the architecture.</p>
<p align="center">
<img width="800" src="img/qpnn.png">
</p>

<p>Mathematically, the system function is given by,</p>
<div class="arithmatex">\[ \mathbf{S} = \mathbf{U}(\boldsymbol{\phi}_L, \boldsymbol{\theta}_L) \cdot
\prod_{i=1}^{L-1}\boldsymbol{\Sigma}(\varphi) \cdot
\mathbf{U}(\boldsymbol{\phi}_i, \boldsymbol{\theta}_i), \]</div>
<p>where <span class="arithmatex">\(\mathbf{U}(\boldsymbol{\phi}_i, \boldsymbol{\theta}_i)\)</span>
is the Clements MZI mesh for the <span class="arithmatex">\(i^\text{th}\)</span> layer and
<span class="arithmatex">\(\boldsymbol{\Sigma}(\varphi)\)</span> represents a section of single-site
Kerr nonlinearities. Note that this equation is not fully correct when
certain nonlinearities are <em>burnt out</em>.</p>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A 2D array, the <span class="arithmatex">\(N\times N\)</span> matrix representation of the QPNN resolved in the Fock basis</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>quotonic/qpnn.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">sysFunc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the system transfer function, $\\mathbf{S}$, of the QPNN.</span>

<span class="sd">    An example QPNN, with two layers, two photons, and four optical modes,</span>
<span class="sd">    is shown below. This function computes the matrix representation of the</span>
<span class="sd">    QPNN, like the one shown below, from the pieces of the architecture.</span>

<span class="sd">    &lt;p align=&quot;center&quot;&gt;</span>
<span class="sd">    &lt;img width=&quot;800&quot; src=&quot;img/qpnn.png&quot;&gt;</span>
<span class="sd">    &lt;/p&gt;</span>

<span class="sd">    Mathematically, the system function is given by,</span>

<span class="sd">    $$ \\mathbf{S} = \\mathbf{U}(\\boldsymbol{\\phi}_L, \\boldsymbol{\\theta}_L) \\cdot</span>
<span class="sd">    \\prod_{i=1}^{L-1}\\boldsymbol{\\Sigma}(\\varphi) \\cdot</span>
<span class="sd">    \\mathbf{U}(\\boldsymbol{\\phi}_i, \\boldsymbol{\\theta}_i), $$</span>

<span class="sd">    where $\\mathbf{U}(\\boldsymbol{\\phi}_i, \\boldsymbol{\\theta}_i)$</span>
<span class="sd">    is the Clements MZI mesh for the $i^\\text{th}$ layer and</span>
<span class="sd">    $\\boldsymbol{\\Sigma}(\\varphi)$ represents a section of single-site</span>
<span class="sd">    Kerr nonlinearities. Note that this equation is not fully correct when</span>
<span class="sd">    certain nonlinearities are *burnt out*.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A 2D array, the $N\\times N$ matrix representation of the QPNN resolved in the Fock basis</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fockDim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numLayers</span><span class="p">):</span>
        <span class="c1"># Encode the single-photon unitary</span>
        <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">[</span><span class="n">L</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

        <span class="c1"># Construct the multi-photon unitary</span>
        <span class="n">PhiU</span> <span class="o">=</span> <span class="n">multiPhotonUnitary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numPhotons</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>

        <span class="c1"># Apply the single-site Kerr nonlinearities</span>
        <span class="k">if</span> <span class="n">L</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">numLayers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">PhiU</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kerrU</span><span class="p">[</span><span class="n">L</span><span class="p">],</span> <span class="n">PhiU</span><span class="p">)</span>

        <span class="c1"># Update the full system matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">PhiU</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>



  </div>

  </div>

</div>




  </div>

  </div>

</div>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Maintained by <a href="https://www.linkedin.com/in/jacobewaniuk/">Jacob Ewaniuk</a>.
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        <div class="md-social">
  
    
    
    
    
      
      
    
    <a href="https://github.com/QNLQueens/quotonic" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://pypi.com/project/quotonic" target="_blank" rel="noopener" title="pypi.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.8 200.5c-7.7-30.9-22.3-54.2-53.4-54.2h-40.1v47.4c0 36.8-31.2 67.8-66.8 67.8H172.7c-29.2 0-53.4 25-53.4 54.3v101.8c0 29 25.2 46 53.4 54.3 33.8 9.9 66.3 11.7 106.8 0 26.9-7.8 53.4-23.5 53.4-54.3v-40.7H226.2v-13.6h160.2c31.1 0 42.6-21.7 53.4-54.2 11.2-33.5 10.7-65.7 0-108.6zM286.2 404c11.1 0 20.1 9.1 20.1 20.3 0 11.3-9 20.4-20.1 20.4-11 0-20.1-9.2-20.1-20.4.1-11.3 9.1-20.3 20.1-20.3zM167.8 248.1h106.8c29.7 0 53.4-24.5 53.4-54.3V91.9c0-29-24.4-50.7-53.4-55.6-35.8-5.9-74.7-5.6-106.8.1-45.2 8-53.4 24.7-53.4 55.6v40.7h106.9v13.6h-147c-31.1 0-58.3 18.7-66.8 54.2-9.8 40.7-10.2 66.1 0 108.6 7.6 31.6 25.7 54.2 56.8 54.2H101v-48.8c0-35.3 30.5-66.4 66.8-66.4zm-6.7-142.6c-11.1 0-20.1-9.1-20.1-20.3.1-11.3 9-20.4 20.1-20.4 11 0 20.1 9.2 20.1 20.4s-9 20.3-20.1 20.3z"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": ".", "features": [], "search": "assets/javascripts/workers/search.208ed371.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="assets/javascripts/bundle.2a6f1dda.min.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>